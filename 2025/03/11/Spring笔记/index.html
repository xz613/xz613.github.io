<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Spring笔记 | 他乡遇故知</title><meta name="author" content="John Doe"><meta name="copyright" content="John Doe"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Spring笔记IOC对象创建的方式：AOP实现方式AOP:面向切面编程：spring 框架用动态代理技术来支持面像切面编程，spring的动态代理有两种方式： 1、JDK动态代理：基于接口的代理 2、CGLB代理：基于类的代理 需要了解两个类：  proxy ：代理 InvocationHandler ：调用处理程序  ​	Invocation Handler内部只有一个方法 object in">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring笔记">
<meta property="og:url" content="https://xz613.github.io/2025/03/11/Spring%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="他乡遇故知">
<meta property="og:description" content="Spring笔记IOC对象创建的方式：AOP实现方式AOP:面向切面编程：spring 框架用动态代理技术来支持面像切面编程，spring的动态代理有两种方式： 1、JDK动态代理：基于接口的代理 2、CGLB代理：基于类的代理 需要了解两个类：  proxy ：代理 InvocationHandler ：调用处理程序  ​	Invocation Handler内部只有一个方法 object in">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://xz613.github.io/img/avator.png">
<meta property="article:published_time" content="2025-03-11T11:12:33.000Z">
<meta property="article:modified_time" content="2025-03-11T11:15:07.731Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://xz613.github.io/img/avator.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Spring笔记",
  "url": "https://xz613.github.io/2025/03/11/Spring%E7%AC%94%E8%AE%B0/",
  "image": "https://xz613.github.io/img/avator.png",
  "datePublished": "2025-03-11T11:12:33.000Z",
  "dateModified": "2025-03-11T11:15:07.731Z",
  "author": [
    {
      "@type": "Person",
      "name": "John Doe",
      "url": "https://xz613.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://xz613.github.io/2025/03/11/Spring%E7%AC%94%E8%AE%B0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.3.5"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.7.2/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Spring笔记',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background: [object Object];"></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background: [object Object];"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/img/avator.png" alt="Logo"><span class="site-name">他乡遇故知</span></a><a class="nav-page-title" href="/"><span class="site-name">Spring笔记</span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">Spring笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-03-11T11:12:33.000Z" title="发表于 2025-03-11 19:12:33">2025-03-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-03-11T11:15:07.731Z" title="更新于 2025-03-11 19:15:07">2025-03-11</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">2.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>8分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h2 id="Spring笔记"><a href="#Spring笔记" class="headerlink" title="Spring笔记"></a>Spring笔记</h2><h3 id="IOC对象创建的方式："><a href="#IOC对象创建的方式：" class="headerlink" title="IOC对象创建的方式："></a>IOC对象创建的方式：</h3><h3 id="AOP实现方式"><a href="#AOP实现方式" class="headerlink" title="AOP实现方式"></a>AOP实现方式</h3><p><strong>AOP</strong>:面向切面编程：spring 框架用动态代理技术来支持面像切面编程，spring的动态代理有两种方式：</p>
<p><strong>1、JDK动态代理：</strong>基于接口的代理</p>
<p><strong>2、CGLB代理：</strong>基于类的代理</p>
<p>需要了解两个类：</p>
<ul>
<li>proxy ：代理</li>
<li>InvocationHandler ：调用处理程序</li>
</ul>
<p>​	Invocation Handler内部只有一个方法</p>
<p>object invoke(objecT proxy,method, object[] args)throws throwable</p>
<p>1、JDK动态代理</p>
<p>​	JDK动态代理是 Java 本身提供的代理机制，要求目标类必须实现接口。Spring 会创建一个目标接口的代理对象，在该对象上执行方法时，实际回委托给InvocationHandler处理。</p>
<h3 id="回顾Servlet"><a href="#回顾Servlet" class="headerlink" title="回顾Servlet"></a>回顾Servlet</h3><p>Servlet 是 Java 编程语言中的一种服务器端技术，用于扩展服务器的功能，尤其是在 Web 应用程序中。它们可以响应客户端（通常是浏览器）发出的请求，并生成动态的 Web 内容。Servlets 是 Java EE（现 Jakarta EE）平台的一部分，广泛用于构建 Web 应用程序。</p>
<p><strong>基本概念</strong>：</p>
<p>Servlet 是一种运行在服务器上的 Java 类，它接收并处理来自客户端的请求，生成相应的响应。Servlet 通常用于动态生成 HTML 内容、处理表单提交、与数据库交互等操作。</p>
<p><strong>工作原理：</strong></p>
<ul>
<li><strong>客户端请求：</strong>客户端（如Web浏览器）像服务器发送请求，通常是HTTP请求。</li>
<li><strong>Servlet容器接受请求：</strong>Web服务器（如Tomcat，Jetty）接受HTTP请求后，将其发送给像应得Servlet。</li>
<li><strong>Servlet处理请求：</strong>Servlet容器通过Servlet得service()方法来处理请求。在service()方法中，Servlet根据请的内容（如GET、POST请求）调用 doGet() 或 dopost()方法来生成响应。</li>
<li><strong>Servlet生成相应：</strong>Servlet 将响应内容( 如 HTML、JSON、XML等发送回客户端)。</li>
</ul>
<h3 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h3><p><strong>初识SpringMVC</strong></p>
<p>Spring MVC 是一个基于 <strong>Java</strong> 的 Web 应用框架，是 <strong>Spring Framework</strong> 的一部分，旨在通过 <strong>Model-View-Controller (MVC)</strong> 设计模式，帮助开发者构建松耦合、易维护的 Web 应用程序。它提供了一个清晰的请求处理流程，支持面向对象的开发，并能与各种视图技术（如 JSP、Thymeleaf）结合使用。</p>
<p><strong>基本概念：</strong></p>
<p><strong>Spring MVC</strong> 是一个轻量级的 Web 框架，它使用 <strong>DispatcherServlet</strong> 作为前端控制器来统一处理 HTTP 请求，并将请求分发给不同的处理器（Controller）。它遵循经典的 <strong>MVC（Model-View-Controller）模式</strong>，使得应用程序的不同部分职责分明：</p>
<ul>
<li><strong>model:</strong>	表示应用程序的核心数据和业务逻辑。通常是 POJO（Plain Old Java Object）类，用来封装数据。</li>
<li><strong>View:</strong>            表示数据的显示(通常是HTML页面)。spring MVC支持多中视图技术，如JSP、Thymeleaf等。</li>
<li><strong>Controller:</strong>   处理用户的请求，协调Model 和  View  之间的交互，最终返回视图。</li>
</ul>
<p><strong>Spring MVC执行原理概述</strong></p>
<p>Spring MVC 的执行原理可以简化为以下几个步骤：</p>
<ol>
<li><strong>客户端发送请求</strong>：浏览器向服务器发送 HTTP 请求。</li>
<li><strong>DispatcherServlet 拦截请求</strong>：所有的请求都经过 <strong>DispatcherServlet</strong>，它是 Spring MVC 的前端控制器，负责统一处理请求。</li>
<li><strong>HandlerMapping 查找处理器（Controller）</strong>：DispatcherServlet 根据请求的 URL 查找对应的 Controller（通过 HandlerMapping）。</li>
<li><strong>Controller 处理请求</strong>：找到对应的 Controller 后，调用该 Controller 中的方法来处理请求。</li>
<li><strong>返回 ModelAndView</strong>：Controller 执行完逻辑后，返回一个 <strong>ModelAndView</strong> 对象，其中包含了模型数据和视图名称。</li>
<li><strong>ViewResolver 解析视图</strong>：DispatcherServlet 使用 <strong>ViewResolver</strong> 来解析视图名称，找到对应的视图资源（例如 JSP 页面）。</li>
<li><strong>渲染视图并响应客户端</strong>：最终，Spring MVC 渲染视图并将生成的 HTML 内容返回给客户端。</li>
</ol>
<p><strong>1. 请求到达 DispatcherServlet</strong></p>
<ul>
<li><strong>DispatcherServlet</strong> 是 Spring MVC 的前端控制器，所有的 HTTP 请求都会首先被它接收和处理。它是一个 Servlet，在 <code>web.xml</code> 中配置。</li>
<li>通过配置 <code>DispatcherServlet</code> 的 <code>url-pattern</code>，通常设置为 <code>/</code>，意味着所有的请求都会通过它进入 Spring MVC 的处理流程。</li>
</ul>
<pre><code class="highlight plaintext">&lt;servlet&gt;
    &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
&lt;/servlet&gt;
&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;</code></pre>

<p><strong>2. DispatcherServlet 查找 HandlerMapping</strong></p>
<ul>
<li>DispatcherServlet 负责将请求转发给合适的 <strong>HandlerMapping</strong>。</li>
<li><strong>HandlerMapping</strong> 根据请求的 URL 查找相应的 <strong>Controller</strong>，并将请求映射到相应的处理方法。</li>
<li>Spring MVC 支持多种 <strong>HandlerMapping</strong>，最常用的是 <strong>RequestMappingHandlerMapping</strong>，它通过分析请求的 URL 和 Controller 中 <code>@RequestMapping</code> 注解的映射关系，来找到对应的处理器方法。</li>
</ul>
<p><strong>3. 调用 Controller 方法</strong></p>
<ul>
<li>一旦 <strong>HandlerMapping</strong> 确定了要执行的 Controller 和方法，它会把请求交给对应的 <strong>Controller</strong>。</li>
<li><strong>Controller</strong> 方法通过业务逻辑处理请求，并将结果封装到 <code>Model</code> 中。方法可以返回一个 <strong>ModelAndView</strong> 对象，其中包含了视图名称和模型数据。</li>
</ul>
<p>例如：</p>
<pre><code class="highlight plaintext">@Controller
public class HelloController &#123;

    @RequestMapping(&quot;/hello&quot;)
    public String hello(Model model) &#123;
        model.addAttribute(&quot;message&quot;, &quot;Hello, Spring MVC!&quot;);
        return &quot;hello&quot;;  // 返回视图名称
    &#125;
&#125;</code></pre>

<p><strong>4. 返回 ModelAndView</strong></p>
<ul>
<li>Controller 方法返回的是一个 <strong>ModelAndView</strong> 对象，它包含了视图的名称和需要传递给视图的数据模型。</li>
<li>例如，<code>&quot;hello&quot;</code> 是视图名称，而 <code>Model</code> 则是包含数据的对象。</li>
</ul>
<p><strong>5. 视图解析（ViewResolver）</strong></p>
<ul>
<li>DispatcherServlet 使用 <strong>ViewResolver</strong> 来解析视图名称（如 <code>&quot;hello&quot;</code>），并找到对应的视图实现（通常是 JSP 或 Thymeleaf 模板）。</li>
<li><strong>ViewResolver</strong> 会根据视图名称（例如 <code>hello</code>）拼接出具体的视图文件路径（例如 <code>/WEB-INF/views/hello.jsp</code>）。</li>
</ul>
<p>配置视图解析器（<code>InternalResourceViewResolver</code>）示例：</p>
<pre><code class="highlight plaintext">&lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;
    &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/views/&quot; /&gt;
    &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;
&lt;/bean&gt;</code></pre>

<ul>
<li>然后，Spring MVC 会通过 <strong>ViewResolver</strong> 查找实际的视图文件，并将模型数据填充到视图中。</li>
</ul>
<p><strong>6. 渲染视图并返回响应</strong></p>
<ul>
<li>一旦视图被解析，Spring MVC 会通过 <strong>View</strong> 渲染最终的 HTML 页面，最终将 HTML 内容返回给客户端浏览器。</li>
<li>视图通常是一个 JSP 文件、Thymeleaf 模板、Freemarker 模板等。</li>
</ul>
<p><strong>7. 请求响应完成</strong></p>
<ul>
<li>最终，客户端接收到响应，浏览器展示渲染后的 HTML 页面。</li>
</ul>
<p><strong>Spring MVC 执行流程图</strong></p>
<pre><code class="highlight plaintext">客户端请求  ---&gt;  DispatcherServlet  ---&gt;  HandlerMapping  ---&gt;  Controller  ---&gt;  返回 ModelAndView
                                |
                           ViewResolver
                                |
                           视图解析
                                |
                           渲染视图 (JSP, Thymeleaf)
                                |
                           返回 HTTP 响应</code></pre>



<h3 id="RequestMapping注解"><a href="#RequestMapping注解" class="headerlink" title="RequestMapping注解"></a>RequestMapping注解</h3><p>@RequestMapping 可以作用于类和方法级别。</p>
<p><strong>类级别映射</strong></p>
<p>通常用于定义一个公共的基础路径，所有方法会继承这个路径。</p>
<pre><code class="highlight plaintext">@Controller
@RequestMapping(&quot;/user&quot;)
public class UserController &#123;

    // 处理请求 /user/list
    @RequestMapping(&quot;/list&quot;)
    public String listUsers() &#123;
        return &quot;userList&quot;;
    &#125;

    // 处理请求 /user/add
    @RequestMapping(&quot;/add&quot;)
    public String addUser() &#123;
        return &quot;addUser&quot;;
    &#125;
&#125;</code></pre>

<p><strong>方法级别映射</strong></p>
<p>在方法级别，<code>@RequestMapping</code> 注解可以通过设置不同的属性来匹配特定的请求。</p>
<pre><code class="highlight plaintext">@Controller
public class UserController &#123;

    // 处理 GET 请求
    @RequestMapping(value = &quot;/user&quot;, method = RequestMethod.GET)
    public String getUser() &#123;
        return &quot;userDetails&quot;;
    &#125;

    // 处理 POST 请求
    @RequestMapping(value = &quot;/user&quot;, method = RequestMethod.POST)
    public String addUser(@RequestBody User user) &#123;
        // 保存用户
        return &quot;userAdded&quot;;
    &#125;
&#125;</code></pre>

<h3 id="RESTFul-风格"><a href="#RESTFul-风格" class="headerlink" title="RESTFul 风格"></a>RESTFul 风格</h3><p>Spring 中的 RESTful 风格 Web 服务设计非常灵活且易于实现。通过使用 <code>@RestController</code> 和相关的注解，开发者可以快速构建符合 REST 架构风格的 API。通过合理设计 URL 和 HTTP 方法，开发出的 Web 服务可以清晰、简洁地实现资源的 CRUD 操作。</p>
<p>常用的操作：</p>
<ul>
<li><code>@GetMapping</code>：获取资源。</li>
<li><code>@PostMapping</code>：创建资源。</li>
<li><code>@PutMapping</code>：更新资源。</li>
<li><code>@DeleteMapping</code>：删除资源。</li>
</ul>
<p>通过 Spring Boot 和 Spring MVC，开发 RESTful 风格的 Web 服务变得更加高效，同时还可以通过集成工具（如 Swagger）提供更好的开发体验。</p>
<h3 id="重定向和转发"><a href="#重定向和转发" class="headerlink" title="重定向和转发"></a><strong>重定向和转发</strong></h3><p>q<br><strong>重定向（Redirect）：</strong>是指服务器告诉客户端 (通常是浏览器) 重新发起一个新的请求到另一个URL,浏览器回请求一个新的URL并显示新的页面。与转发不同，重定向会导致URL发生变化。</p>
<p><strong>转发:</strong>	转发是指服务器内部将请求转发到另一个资源 (例如一个视图或控制器方法)，客户端不知道这个转发过程，浏览器的地址栏也不会发生变化。</p>
<p><strong>转发和重定向的区别：</strong></p>
<table>
<thead>
<tr>
<th>特性</th>
<th>转发（Forward）</th>
<th>重定向（Redirect）</th>
</tr>
</thead>
<tbody><tr>
<td>URL 是否变化</td>
<td>不变化</td>
<td>变化（浏览器地址栏 URL 会改变）</td>
</tr>
<tr>
<td>请求次数</td>
<td>只有一次请求，浏览器与服务器之间不发生新的 HTTP 请求</td>
<td>有两个 HTTP 请求（第一次请求 + 重定向的请求）</td>
</tr>
<tr>
<td>适用场景</td>
<td>内部逻辑处理后转发到另一个页面或视图</td>
<td>页面跳转、避免重复提交表单等</td>
</tr>
<tr>
<td>性能开销</td>
<td>低，只有一次请求</td>
<td>高，包含两次 HTTP 请求</td>
</tr>
<tr>
<td>用户感知</td>
<td>用户不感知发生了转发，地址栏 URL 不变</td>
<td>用户会看到新的 URL</td>
</tr>
<tr>
<td>用途</td>
<td>内部服务器处理请求后转发到另一个资源</td>
<td>发送指令给浏览器重新发起请求，常用于页面跳转</td>
</tr>
</tbody></table>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://xz613.github.io">John Doe</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://xz613.github.io/2025/03/11/Spring%E7%AC%94%E8%AE%B0/">https://xz613.github.io/2025/03/11/Spring%E7%AC%94%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://xz613.github.io" target="_blank">他乡遇故知</a>！</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="/img/avator.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.4/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.4/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/03/11/Mybatis%E9%BB%91%E9%A9%AC%E7%AC%94%E8%AE%B0/" title="Mybatis黑马笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Mybatis黑马笔记</div></div><div class="info-2"><div class="info-item-1">MyBatis  黑马课程对应资料1 Mybatis概述1.1 Mybatis概念  MyBatis 是一款优秀的持久层框架，用于简化 JDBC 开发 MyBatis 本是 Apache 的一个开源项目iBatis, 2010年这个项目由apache software foundation 迁移到了google code，并且改名为MyBatis...</div></div></div></a><a class="pagination-related" href="/2025/03/11/%E7%8B%82%E7%A5%9Espring5/" title="狂神spring5"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">狂神spring5</div></div><div class="info-2"><div class="info-item-1">目录标题 Spring1.1 简介1.2 优点1.3 组成1.4 拓展 IOC理论推导 HelloSpring IOC创建对象的方式 Spring配置5.1 取别名5.2 Bean的配置5.3 import 依赖注入6.1 构造器注入6.2 Set方式注入【重点】6.3 拓展方式注入6.4 Bean作用域 Bean的自动装配7.1 测试7.2 ByName自动装配7.3 ByType自动装配7.4 使用注解实现自动装配 使用注解开发 用JAVA的方式配置Spring 代理模式10.1 静态代理10.2 加深理解10.3 动态代理 AOP11.1 什么是AOP11.2 AOP在Spring中的作用11.3 使用Spring实现AOP 整合Mybatis12.1 回忆Mybatis12.2 Mybatis-Spring 声明式事务13.1 回顾事务13.2 Spring中的事务管理 总结  1.Spring1.1...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/avator.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">John Doe</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">9</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>关注我</span></a><div class="card-info-social-icons"><a class="social-icon" href="/13048559773@163.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">这是我的博客</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring%E7%AC%94%E8%AE%B0"><span class="toc-number">1.</span> <span class="toc-text">Spring笔记</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#IOC%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E7%9A%84%E6%96%B9%E5%BC%8F%EF%BC%9A"><span class="toc-number">1.1.</span> <span class="toc-text">IOC对象创建的方式：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AOP%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">1.2.</span> <span class="toc-text">AOP实现方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E9%A1%BEServlet"><span class="toc-number">1.3.</span> <span class="toc-text">回顾Servlet</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SpringMVC"><span class="toc-number">1.4.</span> <span class="toc-text">SpringMVC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RequestMapping%E6%B3%A8%E8%A7%A3"><span class="toc-number">1.5.</span> <span class="toc-text">RequestMapping注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RESTFul-%E9%A3%8E%E6%A0%BC"><span class="toc-number">1.6.</span> <span class="toc-text">RESTFul 风格</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E5%AE%9A%E5%90%91%E5%92%8C%E8%BD%AC%E5%8F%91"><span class="toc-number">1.7.</span> <span class="toc-text">重定向和转发</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/11/springboot%E7%AC%94%E8%AE%B0%E5%B0%8F%E7%BB%93/" title="springboot笔记小结">springboot笔记小结</a><time datetime="2025-03-11T11:20:40.000Z" title="发表于 2025-03-11 19:20:40">2025-03-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/11/%E7%8B%82%E7%A5%9Espring5/" title="狂神spring5">狂神spring5</a><time datetime="2025-03-11T11:14:04.000Z" title="发表于 2025-03-11 19:14:04">2025-03-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/11/Spring%E7%AC%94%E8%AE%B0/" title="Spring笔记">Spring笔记</a><time datetime="2025-03-11T11:12:33.000Z" title="发表于 2025-03-11 19:12:33">2025-03-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/11/Mybatis%E9%BB%91%E9%A9%AC%E7%AC%94%E8%AE%B0/" title="Mybatis黑马笔记">Mybatis黑马笔记</a><time datetime="2025-03-11T11:06:54.000Z" title="发表于 2025-03-11 19:06:54">2025-03-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/11/Redis%E5%B0%8F%E7%BB%93/" title="Redis小结">Redis小结</a><time datetime="2025-03-11T11:00:26.000Z" title="发表于 2025-03-11 19:00:26">2025-03-11</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By John Doe</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.3.5"></script><script src="/js/main.js?v=5.3.5"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (false) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.4.1/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>