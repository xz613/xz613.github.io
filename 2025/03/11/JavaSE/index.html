<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>JavaSE | 他乡遇故知</title><meta name="author" content="John Doe"><meta name="copyright" content="John Doe"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="第一章：Java语言概述​	软件开发 ​		软件:按照特定顺序组织的计算机数据和指令的集合。 ​	常见的DOS命令: ​		dir:累出当前目录下的文件以及文件夹 ​		md:创建目录 ​		rd:删除目录 ​		cd:进入指定目录 ​		del:删除文件 ​		exit:退出dos命令行 ​	Java语言特性  面向对象 健壮的 跨平台性  ​ 第二章：变量与运算符​	关键字 ​	定义：被jav">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaSE">
<meta property="og:url" content="https://xz613.github.io/2025/03/11/JavaSE/index.html">
<meta property="og:site_name" content="他乡遇故知">
<meta property="og:description" content="第一章：Java语言概述​	软件开发 ​		软件:按照特定顺序组织的计算机数据和指令的集合。 ​	常见的DOS命令: ​		dir:累出当前目录下的文件以及文件夹 ​		md:创建目录 ​		rd:删除目录 ​		cd:进入指定目录 ​		del:删除文件 ​		exit:退出dos命令行 ​	Java语言特性  面向对象 健壮的 跨平台性  ​ 第二章：变量与运算符​	关键字 ​	定义：被jav">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://xz613.github.io/img/avator.png">
<meta property="article:published_time" content="2025-03-11T10:48:31.000Z">
<meta property="article:modified_time" content="2025-03-11T10:51:24.593Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://xz613.github.io/img/avator.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "JavaSE",
  "url": "https://xz613.github.io/2025/03/11/JavaSE/",
  "image": "https://xz613.github.io/img/avator.png",
  "datePublished": "2025-03-11T10:48:31.000Z",
  "dateModified": "2025-03-11T10:51:24.593Z",
  "author": [
    {
      "@type": "Person",
      "name": "John Doe",
      "url": "https://xz613.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://xz613.github.io/2025/03/11/JavaSE/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.3.5"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.7.2/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'JavaSE',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background: [object Object];"></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background: [object Object];"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/img/avator.png" alt="Logo"><span class="site-name">他乡遇故知</span></a><a class="nav-page-title" href="/"><span class="site-name">JavaSE</span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">JavaSE</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-03-11T10:48:31.000Z" title="发表于 2025-03-11 18:48:31">2025-03-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-03-11T10:51:24.593Z" title="更新于 2025-03-11 18:51:24">2025-03-11</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">13.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>50分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h3 id="第一章：Java语言概述"><a href="#第一章：Java语言概述" class="headerlink" title="第一章：Java语言概述"></a>第一章：Java语言概述</h3><p>​	<strong>软件开发</strong></p>
<p>​		软件:按照特定顺序组织的计算机数据和指令的集合。</p>
<p>​	<strong>常见的DOS命令</strong>:</p>
<p>​		dir:累出当前目录下的文件以及文件夹</p>
<p>​		md:创建目录</p>
<p>​		rd:删除目录</p>
<p>​		cd:进入指定目录</p>
<p>​		del:删除文件</p>
<p>​		exit:退出dos命令行</p>
<p>​	<strong>Java语言特性</strong></p>
<ul>
<li>面向对象</li>
<li>健壮的</li>
<li>跨平台性</li>
</ul>
<p>​</p>
<h3 id="第二章：变量与运算符"><a href="#第二章：变量与运算符" class="headerlink" title="第二章：变量与运算符"></a>第二章：变量与运算符</h3><p>​	<strong>关键字</strong></p>
<p>​	定义：被java语言赋予了特殊含义，用做专门用途的字符串</p>
<p>​	特点:   都为小写</p>
<p>​	地址：<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/tutorial/java/nutsandbolts/_keywords.html">Java Language Keywords (The Java™ Tutorials &gt; Learning the Java Language &gt; Language Basics)</a></p>
<p>​</p>
<p>​	<strong>标识符</strong>:</p>
<p>​	定义:对各种变量，方法和类等要素的命名使用的字符序列称为标识符</p>
<p>​	凡是可以自己起名字的地方都叫标识符</p>
<p>​</p>
<p>​	<strong>Java中的名称命名规范;</strong></p>
<ul>
<li>包名:	            多单词组成时所有字母都小写;xxxyyyzzz</li>
<li>类名，接口名：   多单词组成时，所有的首字母大写; XxxYyyZzz</li>
<li>变量名、方法名：多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写;  xxxYyyZzz</li>
<li>常量名:                  所有字母都大写。多单词每个单词用下划线连接；XXX_YYY_ZZZ</li>
</ul>
<p>​	<strong>变量的分类</strong></p>
<pre><code class="highlight plaintext">变量
├── 基本数据类型（Primitive Type）
	数值型
│   ├── byte
│   ├── short
│   ├── int
│   ├── long
│   ├── float
│   ├── double
	字符型
│   ├── char
	布尔型
│   └── boolean
│
└── 引用数据类型（Reference Type）
    ├── 类（Class）
    │   └── String, MyClass, ...
    ├── 接口（Interface）
    │   └── List, Runnable, ...
    ├── 数组（Array）
    │   └── int[], String[], ...
    └── 枚举（Enum）
        └── Day, Month, ...
</code></pre>



<p>​	<strong>强制类型转换</strong></p>
<p>​	大 –&gt; 小 : 使用强转符号（）;可能会造成精度降低或溢出.</p>
<p>​</p>
<h3 id="第三章：流程控制语句"><a href="#第三章：流程控制语句" class="headerlink" title="第三章：流程控制语句"></a>第三章：流程控制语句</h3><p><strong>基本流程结构</strong></p>
<ul>
<li>顺序结构</li>
<li>分支结构</li>
</ul>
<ol>
<li>if…else</li>
<li>switch-case</li>
</ol>
<ul>
<li>循环结构</li>
</ul>
<ol>
<li>while</li>
<li>do…while…</li>
<li>for</li>
</ol>
<h3 id="第五章：数组"><a href="#第五章：数组" class="headerlink" title="第五章：数组"></a>第五章：数组</h3><p>​	**数组的概念:**多个相同数据类型按一定顺序排列的集合。</p>
<p>​</p>
<p>​	<strong>一维数组的声明方式:</strong></p>
<p>​	type var[] 或 type[] var；</p>
<p>​	例如：</p>
<p>​		int a[];</p>
<p>​		int[] a1;</p>
<p>​		double b[];</p>
<p>​		String[] c; &#x2F;&#x2F;引用类型变量数组</p>
<p>​	5. <strong>多维数组</strong></p>
<p>​		Java支持多维数组，最常见的是二维数组。数组的维度可以是任意的，但通常二维数组		用于表示矩阵或表格。</p>
<p>​	<strong>二维数组的声明与初始化：</strong></p>
<pre><code class="highlight plaintext">java

int[][] matrix = new int[3][3];  // 创建一个3x3的二维数组</code></pre>

<ul>
<li><strong>初始化并赋值</strong>：</li>
</ul>
<pre><code class="highlight plaintext">java

int[][] matrix = &#123;
    &#123;1, 2, 3&#125;,
    &#123;4, 5, 6&#125;,
    &#123;7, 8, 9&#125;
&#125;;</code></pre>

<p><strong>访问二维数组的元素：</strong></p>
<pre><code class="highlight plaintext">java

System.out.println(matrix[0][0]);  // 输出 1
System.out.println(matrix[2][2]);  // 输出 9</code></pre>

<p>​</p>
<p><strong>数组中涉及的常见算法</strong></p>
<ol>
<li>数组元素的赋值(杨辉三角、回形数等)</li>
<li>求数值型数组中的最大值，最小值，平均数，总和等</li>
<li>数组的复制、反转、查找(线性查找，二分查找)</li>
<li>数组元素的排序算法</li>
</ol>
<p>​</p>
<h3 id="第六章：面向对象-基础"><a href="#第六章：面向对象-基础" class="headerlink" title="第六章：面向对象(基础)"></a>第六章：面向对象(基础)</h3><p>​	<strong>面向对象的三大特征:</strong>    封装、继承、多态</p>
<p>​	<strong>面向对像的思想概述:</strong></p>
<p>​		类、和对象 是面向对象的核心概念</p>
<ul>
<li>​	类、是对一类事物的描述，是抽象的，概念上的定义</li>
<li>​        对象、是实际存在的该类事务的每个个体，因而也称为实例。</li>
</ul>
<h3 id="第七章：面向对象-进阶"><a href="#第七章：面向对象-进阶" class="headerlink" title="第七章：面向对象(进阶)"></a>第七章：面向对象(进阶)</h3><p>​	<strong>方法的重写:</strong></p>
<p>​		在子类中可以根据需要对从父类中继承来的方法进行改造，也称</p>
<p>​		为方法的重置、覆盖。在程序执行时，子类的方法将覆盖父类的方法。</p>
<p>​	<strong>四种访问权限修饰符:</strong></p>
<p><strong>1、public</strong></p>
<ul>
<li>可见性：最宽泛的访问控制修饰符，表示该成员可以被任何其他类访问，不受任何限制。</li>
<li>适用范围<ul>
<li>对类、方法、字段都有效。</li>
<li>如果一个类被声明为<code>public</code>，则该类可以被任何其他类访问。</li>
</ul>
</li>
</ul>
<p><strong>2、protected</strong></p>
<ul>
<li><strong>可见性</strong>：表示该成员可以被同一个包中的类访问，或者被任何继承该类的子类访问（无论子类是否在同一包中）。</li>
<li>适用范围:<ul>
<li>对字段、方法、构造函数有效。</li>
<li>只能被同一个包中的类或子类访问。</li>
</ul>
</li>
</ul>
<p>在这个例子中，<code>name</code>和<code>speak()</code>被声明为<code>protected</code>，可以被同一个包中的类以及继承<code>Animal</code>类的子类访问。</p>
<p><strong>3、private</strong></p>
<ul>
<li><strong>可见性</strong>：最严格的访问控制修饰符，表示该成员只能在当前类内部访问，不能被其他类访问。</li>
<li>适用范围:<ul>
<li>对字段、方法、构造函数有效。</li>
<li>只能在定义该成员的类内部访问。</li>
</ul>
</li>
</ul>
<p>在这个例子中，<code>name</code>和<code>setName()</code>方法被声明为<code>private</code>，只能在<code>Person</code>类内部访问。外部类无法直接访问这些成员。</p>
<p><strong>4、缺省</strong></p>
<ul>
<li><p><strong>可见性</strong>：如果没有指定访问修饰符，默认使用包私有访问权限。也就是说，成员仅对同一包中的其他类可见，其他包中的类不能访问。</p>
</li>
<li><p>适用范围：</p>
<ul>
<li><p>对字段、方法、构造函数有效。</p>
</li>
<li><p>仅在同一个包内的类可以访问，其他包中的类无法访问。</p>
</li>
</ul>
</li>
</ul>
<p><strong>对象的多态性：</strong></p>
<p>​	父类的引用指向子类的对象。</p>
<p>​	格式:</p>
<pre><code class="highlight plaintext">父类类型 变量名 = 子类对象

Person p = new Student();</code></pre>



<h3 id="第八章：面向对象-高级"><a href="#第八章：面向对象-高级" class="headerlink" title="第八章：面向对象(高级)"></a>第八章：面向对象(高级)</h3><p>​	1、<strong>基本数据类型、包装类 和 String 类型的转换：</strong></p>
<p>​	（1）、基本数据类型、包装类   &#x3D;&#x3D;&gt;   String 类型：调用String的重载的静态方法 —  valueof(xxx); （2）、基本数据类型的变量 +  “”</p>
<pre><code class="highlight plaintext">int i1 = 10;
      String str1 = String.valueOf(i1);
      System.out.print(str1);
      
      String str2 = i1 + &quot;&quot;;</code></pre>

<p>​	 (2)、 String 类型  &#x3D;&#x3D;&gt;  基本数据类型, 调用包装类的parseXXX();</p>
<pre><code class="highlight plaintext">String str3 = &quot;123&quot;;
      int i2 = Integer.parseInt(str3);
      System.out.println(i2);</code></pre>



<p>​	<strong>static关键字:</strong></p>
<p>​	在Java类中，可用static修饰属性、方法、代码块、内部类</p>
<p>​	被修饰后的成员具备以下特点:</p>
<ul>
<li><p>​		随着类的加载而加载</p>
</li>
<li><p>​		优先于对象存在</p>
</li>
<li><p>​		修饰的成员，被所有对象所共享</p>
</li>
<li><p>​		访问权限允许时，可不创建对象，直接被类调用</p>
</li>
</ul>
<p>​	<strong>抽象类和抽象方法</strong></p>
<ul>
<li><p>​	<strong>抽象方法：</strong>只有方法签名，没有方法体的，我们把没有方法体的方法称为抽象方法；</p>
</li>
<li><p>​       <strong>抽象类：</strong>表述不清楚的类，被abstract修饰的类</p>
<p>注意： 抽象类不一定包含抽象方法，包含抽象方法的类一定是抽象类。</p>
</li>
</ul>
<p>​	<strong>接口Interface</strong></p>
<ul>
<li><strong>定义：</strong>一种特殊的抽象类型，定义的了一组方法的声明，但没有实现。</li>
</ul>
<p>​</p>
<p>​	<strong>接口和抽象类的区别：</strong></p>
<ol>
<li>​	接口中的方法是抽象的（除了默认方法），抽象类中的方法可以是抽象方法和已经实现的方法。</li>
<li>​         一个类可以实现多个接口，只能继承一个抽象类。</li>
<li>​         接口不能有构造方法。</li>
</ol>
<p>​	<strong>内部类</strong></p>
<ol>
<li><p>成员内部类</p>
</li>
<li><p>局部内部类</p>
</li>
<li><p>匿名内部类</p>
<pre><code class="highlight plaintext">class OuterClass &#123;
    public void display() &#123;
        // 使用匿名内部类实现 Runnable 接口
        Runnable runnable = new Runnable() &#123;
            @Override
            public void run() &#123;
                System.out.println(&quot;Running in an anonymous inner class.&quot;);
            &#125;
        &#125;;
        runnable.run();  // 输出: Running in an anonymous inner class.
    &#125;
&#125;

public class Main &#123;
    public static void main(String[] args) &#123;
        OuterClass outer = new OuterClass();
        outer.display();
    &#125;
&#125;</code></pre>

<h4 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h4><ul>
<li>匿名内部类没有类名，直接在创建对象时定义并实例化。</li>
<li>在上面的例子中，匿名内部类实现了 <code>Runnable</code> 接口，重写了 <code>run()</code> 方法。</li>
<li>匿名内部类通常用于那些只需要一次使用的类，通常用于事件监听器、回调函数等。</li>
</ul>
</li>
<li><p>静态内部类</p>
</li>
</ol>
<p>​		静态内部类可以访问外部类的静态成员，但不能访问外部类的实例成员。</p>
<h3 id="第九章：异常处理"><a href="#第九章：异常处理" class="headerlink" title="第九章：异常处理"></a>第九章：异常处理</h3><p>​	<strong>异常</strong></p>
<p>​	1、什么是异常?</p>
<p>​			程序执行过程中，出现的非正常情况。</p>
<p>​	2、异常的抛出机制</p>
<p>​			在程序中不同的异常用不同的类表示，当出现异常时，就创建该类的实例对象，并且抛出(throw)。然后程序员就会捕捉(cathe)到这个异常对象,并处理；如果没有捕获到这个异常对象，那么程序即将终止。</p>
<p>​	3、异常的体系结构</p>
<p>​			java.lang.Throwable：异常体系的根父类</p>
<p>​					java.lang.Error ： JVM不能恢复的严重问题,如内存溢出等。</p>
<p>​					java.lang .Exception: 程序可以处理的异常。</p>
<p>​</p>
<pre><code class="highlight plaintext">Throwable
├── Error
└── Exception
    ├── IOException (Checked Exception)
    └── RuntimeException (Unchecked Exception)
        ├── NullPointerException
        ├── ArrayIndexOutOfBoundsException
        └── ArithmeticException</code></pre>

<p><strong>异常的处理方式之一  try-catch</strong></p>
<pre><code class="highlight plaintext">try &#123;
    // 可能抛出异常的代码
&#125; catch (ExceptionType e) &#123;
    // 处理异常的代码
&#125;
</code></pre>

<p><strong>异常处理 finally的使用</strong></p>
<p>​	在异常的处理中,finally 的代码块总会执行,无论是否发生异常。</p>
<p>​	格式：</p>
<pre><code class="highlight plaintext">try &#123;
    // 可能抛出异常的代码
&#125; catch (ExceptionType e) &#123;
    // 处理异常的代码
&#125; finally &#123;
    // 无论是否发生异常，都会执行的代码
&#125;
</code></pre>

<p>​	特点:</p>
<p>​	（1）、总是执行：无论异常是否发生，都会执行finally块中的代码。</p>
<p>​	（2）、用于清理：通常用于释放资源，或者关闭流。</p>
<p>​	（3）、与return语句结合使用：在try catch块中，如果在有return  语句，finnally 块也会在返回前执行。</p>
<p><strong>异常的处理方式二   throws</strong></p>
<p>​	（1）、thorws关键字用于抛出所有可能发生的异常，用逗号将类型隔开。</p>
<p>​	语法：</p>
<pre><code class="highlight plaintext">public void someMethod() throws IOException, SQLException &#123;
    // 可能抛出 IOException 或 SQLException 的代码
&#125;
</code></pre>

<p>​	（2）、子类异常</p>
<p>​	如果一个方法声明抛出一个异常，它的子类也会被视为合法的抛出异常。例如，如果一个方法声明抛出 <code>IOException</code>，那么可以抛出 <code>FileNotFoundException</code>（<code>IOException</code> 的子类）。</p>
<p><strong>如何自定义异常类</strong></p>
<p>​	(1)如何自定义异常类</p>
<ul>
<li>通常继承已有的异常体系，通常继承RuntimeExceeption \ Exception</li>
<li>申明多个构造器</li>
<li>申明一个全局常量，static final long serailVersionUID;</li>
</ul>
<p>​</p>
<h3 id="第十章：多线程"><a href="#第十章：多线程" class="headerlink" title="第十章：多线程"></a>第十章：多线程</h3><h4 id="1、多线程—程序，进程，线程与并发，并行的概念"><a href="#1、多线程—程序，进程，线程与并发，并行的概念" class="headerlink" title="1、多线程—程序，进程，线程与并发，并行的概念"></a><strong>1、多线程—程序，进程，线程与并发，并行的概念</strong></h4><ul>
<li><p>什么是进程？</p>
<p>—程序的一次执行过程。或是正在运行中的程序，例如qq，微信等。</p>
<p><strong>操作系统调度和分配资源的最小单位。</strong></p>
</li>
<li><p>什么是线程？</p>
<p>—进程可进一步细化为线程，是程序内部的一条执行路径。</p>
<p>单线程 ——&gt; 一个进程只支持一个线程</p>
<p>多线程 ——&gt; 一个进程支持多个线程，一个进程在同一时间并行多个线程。</p>
<p>线程是cpu调度的最小单位。</p>
</li>
<li><p>什么是并行？</p>
<p>—两个或多个事件同时发生，同一时刻，有两条指令在cpu上共同执行。</p>
</li>
<li><p>什么是并发？</p>
<p>—两个或多个事件在同一时段发生，在一段时间内，有多条指令在cpu上快速的轮换，交替执行，在宏观上造成了并行的效果。</p>
</li>
</ul>
<h4 id="2、多线程，线程的创建方式"><a href="#2、多线程，线程的创建方式" class="headerlink" title="2、多线程，线程的创建方式"></a><strong>2、多线程，线程的创建方式</strong></h4><p><strong>方式一  继承 Thread类</strong></p>
<p>​	通过继承thread类，重写run()方法,可以实现自定义线程的创建。通过使用start()方式可以启动自定义的线程.</p>
<p>​	例:</p>
<pre><code class="highlight plaintext">class MyThread extends Thread &#123;
    @Override
    public void run() &#123;
        // 线程执行的代码
        System.out.println(&quot;Thread is running!&quot;);
    &#125;
&#125;

public class ThreadExample &#123;
    public static void main(String[] args) &#123;
        MyThread thread = new MyThread();  // 创建线程对象
        thread.start();  // 启动线程
    &#125;
&#125;
</code></pre>

<p>解释：</p>
<ul>
<li>继承   thread  类并重写run() 方法，run()方法定义了要实现的任务。</li>
<li>使用start() 启动线程，而不是直接调用run(), 否则会在当前线程中执行run()方法，不会创建新线程。</li>
</ul>
<p><strong>方式二  实现Runable 接口</strong></p>
<p>​	通过继承 Runnable 接口,重写 Runnable 的run() 方法,可以创建线程。然后将  Runnable 对象传递给 Thread 类的构造器来启动线程。</p>
<pre><code class="highlight plaintext">class MyRunnable implements Runnable &#123;
    @Override
    public void run() &#123;
        // 线程执行的代码
        System.out.println(&quot;Thread is running via Runnable!&quot;);
    &#125;
&#125;

public class ThreadExample &#123;
    public static void main(String[] args) &#123;
        MyRunnable myRunnable = new MyRunnable();  // 创建Runnable对象
        Thread thread = new Thread(myRunnable);    // 将Runnable对象传递给Thread构造器
        thread.start();  // 启动线程
    &#125;
&#125;
</code></pre>

<p>解释：</p>
<ul>
<li>实现Runnable 接口，重写run()方法，实现线程要执行的任务。</li>
<li>将 Runnable 实现类的对象传递给 thread 类的构造方法，创建线程对象。</li>
<li>这种方法比继承 <code>Thread</code> 更灵活，因为 Java 支持多继承的接口，而继承 <code>Thread</code> 类就不能继承其他类。</li>
</ul>
<p><strong>方式三、实现 Callable 接口</strong></p>
<ul>
<li>实现 Callable  接口并重写 call() 方法。Call() 方法有返回值，并且可以抛出异常。</li>
<li>通常与 ExecutorService  一起使用，通过线程池来管理线程。</li>
</ul>
<pre><code class="highlight plaintext">import java.util.concurrent.*;

class MyCallable implements Callable&lt;Integer&gt; &#123;
    @Override
    public Integer call() &#123;
        return 123;
    &#125;
&#125;

public class CallableExample &#123;
    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;
        ExecutorService executor = Executors.newFixedThreadPool(2);
        MyCallable task = new MyCallable();
        Future&lt;Integer&gt; result = executor.submit(task);
        System.out.println(&quot;Result: &quot; + result.get());
        executor.shutdown();
    &#125;
&#125;</code></pre>



<p><strong>方式四、使用线程池(ExecutorService)</strong></p>
<ul>
<li><p>线程池是创建和管理线程的最佳方式，他可以高效的复用线程，减少线程的创建和消耗成本。</p>
</li>
<li><p>使用ExcutorService( 例如 newFixedThread、newCachedThreadPool)来管理线程池中的线程。</p>
</li>
</ul>
<pre><code class="highlight plaintext">ExecutorService executor = Executors.newFixedThreadPool(3);
Runnable task = () -&gt; System.out.println(Thread.currentThread().getName() + &quot; is running&quot;);
for (int i = 0; i &lt; 5; i++) &#123;
    executor.submit(task);
&#125;
executor.shutdown();  // 关闭线程池</code></pre>



<p><strong>线程的生命周期:</strong></p>
<ol>
<li><p>**新建状态 (New)**：线程对象被创建，但尚未启动。此时，线程处于新建状态。</p>
<pre><code class="highlight plaintext">Thread thread = new Thread();  // 线程处于 &quot;新建&quot; 状态</code></pre>
</li>
<li><p>**就绪状态 (Runnable)**：线程准备好执行，但等待系统分配好时间片。</p>
<pre><code class="highlight plaintext">Thread thread = new Thread(() -&gt; &#123;
    // 线程执行的任务
&#125;);
thread.start();  // 线程进入 &quot;就绪&quot; 状态</code></pre>
</li>
<li><p>**运行状态 (Running)**：线程获得 CPU 时间片，正在执行其 <code>run()</code> 方法。</p>
<pre><code class="highlight plaintext">Thread thread = new Thread(() -&gt; &#123;
    System.out.println(&quot;Running thread...&quot;);
&#125;);
thread.start();  // 线程进入 &quot;运行&quot; 状态</code></pre>
</li>
<li><p>**阻塞状态 (Blocked)**：线程因为等待锁或资源，而被阻塞，无法继续执行。</p>
<pre><code class="highlight plaintext">synchronized (lock) &#123;
    // 当前线程在等待锁，若锁已被其他线程占用，它将进入 &quot;阻塞&quot; 状态
&#125;</code></pre>
</li>
<li><p><strong>等待状态：</strong>线程进入等待状态，等待其他线程的唤醒。</p>
<pre><code class="highlight plaintext">synchronized (lock) &#123;
    try &#123;
        lock.wait();  // 当前线程进入 &quot;等待&quot; 状态，直到被唤醒
    &#125; catch (InterruptedException e) &#123;
        e.printStackTrace();
    &#125;
&#125;</code></pre>
</li>
<li><p>**定时状态:**线程在一定时间内被挂起，直到时间到期或者被唤醒。</p>
<pre><code class="highlight plaintext">Thread.sleep(1000);  // 当前线程进入 &quot;定时等待&quot; 状态，等待 1000 毫秒</code></pre>
</li>
<li><p>**死亡状态 (Terminated)**：线程执行完成，进入终止状态，无法再次启动。</p>
<pre><code class="highlight plaintext">Thread thread = new Thread(() -&gt; &#123;
    System.out.println(&quot;Thread has finished execution.&quot;);
&#125;);
thread.start();  // 执行完后线程进入 &quot;死亡&quot; 状态
</code></pre></li>
</ol>
<p><strong>多线程Thread类的常用方法</strong></p>
<p>1、常用方法：</p>
<ul>
<li><p>start() 	——&gt; 启动线程 ，调用线程 run();</p>
</li>
<li><p>run()           ——&gt;将线程要中执行的操作写在方法体内。</p>
</li>
<li><p>currentThread()    ——&gt;获取当前执行代码的线程</p>
</li>
<li><p>getName()    ——&gt;获取线程名</p>
</li>
<li><p>setName()    ——&gt; 设置线程名</p>
</li>
<li><p>sleep(long mills)  ——&gt;  静态方法，可以使当前的线程睡眠指定的毫秒数。</p>
</li>
<li><p>join()  ——&gt;等待该线程完成，调用该方法的线程会被阻塞，直到目标线程结束。</p>
</li>
<li><p>yield() ——&gt;让当前线程暂停，主动让出 CPU 时间，允许其他线程执行</p>
</li>
<li><p>isAlive()  ——&gt;检查线程是否还在运行</p>
</li>
</ul>
<h4 id="3、线程安全问题"><a href="#3、线程安全问题" class="headerlink" title="3、线程安全问题"></a><strong>3、线程安全问题</strong></h4><p>​		原因：当多个线程被创建，且同一时间访问共享资源，就会触发线程的安全问题。</p>
<p>​		解决：添加 同步监视器（锁），那个线程获得了锁，那个线程就能执行需要同步的资源。</p>
<p><strong>线程的同步方式</strong>(解决线程安全问题的其中一种方式)</p>
<p><strong>1、使用synchronized关键字</strong></p>
<p>synchronized 关键字是Java 中最基本的同步机制，他通过加锁来确保在同一时刻只有一个线程可以访问共享资源，从而避免了线程之间的竞争条件。</p>
<p><strong>1.1同步方法</strong></p>
<p>通过在方法声明中使用 synchronized 关键字，使得该方法在同一时刻再能被一个线程调用，对于实例方法，加锁的是当前对象实例，对于静态方法，枷锁的是类的Class 对象。</p>
<pre><code class="highlight plaintext">class Counter &#123;
    private int count = 0;

    // 同步方法
    public synchronized void increment() &#123;
        count++;
    &#125;

    public synchronized int getCount() &#123;
        return count;
    &#125;
&#125;</code></pre>

<p><strong>说明</strong>：</p>
<ul>
<li>当一个线程调用 <code>increment()</code> 方法时，它会自动获得 <code>Counter</code> 对象的锁，其他线程只能等待。</li>
<li>静态方法：<code>synchronized</code> 修饰静态方法时，锁的是类的 Class 对象，所有实例共享这把锁。</li>
</ul>
<p><strong>1.2同步代码块</strong></p>
<p>​	同步代码块是将同步限制在代码块的某一部分。表示对这个区块的资源实行互斥访问。</p>
<pre><code class="highlight plaintext">class Counter &#123;
    private int count = 0;

    public void increment() &#123;
        synchronized (this) &#123;  // 对代码块加锁
            count++;
        &#125;
    &#125;

    public int getCount() &#123;
        synchronized (this) &#123;  // 对代码块加锁
            return count;
        &#125;
    &#125;
&#125;</code></pre>

<ul>
<li>说明:<ul>
<li>synchronized(this): 同步代码块通过加锁对象来确保线程安全。</li>
<li>可以使用任何对象作为锁，this是锁的常用选择，也可以使用其他对象作为锁。</li>
</ul>
</li>
</ul>
<p><strong>2、Reentranlock类</strong></p>
<p>​	Reentranlock 是  java.util.concurrent.lock包中的一个类，比synchronized 灵活，它可以更细粒度的提供锁的控制。</p>
<pre><code class="highlight plaintext">import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class Example &#123;
    private final Lock lock = new ReentrantLock();

    public void method() &#123;
        lock.lock();  // 获取锁
        try &#123;
            // 临界区代码
        &#125; finally &#123;
            lock.unlock();  // 确保释放锁
        &#125;
    &#125;
&#125;</code></pre>

<p><strong>特点</strong>：</p>
<ul>
<li><p><code>ReentrantLock</code> 提供了显式的锁获取和释放。</p>
</li>
<li><p>可以在 <code>try-catch</code> 块中使用，确保锁能够被释放。</p>
</li>
<li><p>允许尝试锁定（<code>tryLock</code>）和定时锁定（<code>lockInterruptibly</code>），这些是 <code>synchronized</code> 不具备的功能。</p>
</li>
</ul>
<p><strong>2.1：尝试锁(trylock)</strong></p>
<pre><code class="highlight plaintext">if (lock.tryLock()) &#123;
    try &#123;
        // 临界区代码
    &#125; finally &#123;
        lock.unlock();
    &#125;
&#125; else &#123;
    // 锁获取失败，可以执行其他操作
&#125;</code></pre>

<p><strong>特点</strong>：<code>tryLock()</code> 尝试获取锁，如果获取不到锁则返回 <code>false</code>，不会阻塞当前线程。</p>
<p><strong>3、ReadWriteLock</strong></p>
<p>ReadWriteLock 是一种更高级的锁，它允许多个线程并发的读取资源，但在写操作时只允许一个线程</p>
<p>访问该资源。ReentranReadWriteLock 是  ReadWriteLock 接口的实现。</p>
<pre><code class="highlight plaintext">import java.util.concurrent.locks.ReentrantReadWriteLock;

public class Example &#123;
    private final ReentrantReadWriteLock lock = new ReentrantReadWriteLock();

    public void read() &#123;
        lock.readLock().lock();
        try &#123;
            // 读取操作
        &#125; finally &#123;
            lock.readLock().unlock();
        &#125;
    &#125;

    public void write() &#123;
        lock.writeLock().lock();
        try &#123;
            // 写入操作
        &#125; finally &#123;
            lock.writeLock().unlock();
        &#125;
    &#125;
&#125;
</code></pre>

<p><strong>特点</strong>：</p>
<ul>
<li>多个线程可以同时获取读锁，执行读取操作。</li>
<li>写锁是互斥的，获取写锁时，其他线程无法获取读锁或写锁。</li>
</ul>
<p><strong>适用场景</strong>：当读取操作远远多于写操作时，使用 <code>ReadWriteLock</code> 可以提高程序的并发性。</p>
<p><strong>懒汉式单例模式的实现步骤</strong></p>
<ol>
<li>私有构造函数：防止外部直接创造实例</li>
<li>静态私有变量:  用于存储单例对象</li>
<li>公共静态方法:  提供单例对象的全局访问点，并在首次调用时候初始化实例。</li>
</ol>
<pre><code class="highlight plaintext">public class Singleton &#123;
    // 静态私有变量，用于保存单例实例
    private static Singleton instance;

    // 私有构造函数，防止外部创建实例
    private Singleton() &#123;&#125;

    // 公共静态方法，提供访问单例实例的全局访问点
    public static Singleton getInstance() &#123;
        // 首次调用时创建实例
        if (instance == null) &#123;
            instance = new Singleton();
        &#125;
        return instance;
    &#125;
&#125;
</code></pre>





<p>死锁的必要条件</p>
<ol>
<li><strong>互斥条件</strong>: 至少有一个资源处于非共享模式，即这个资源只能别一个线程持有。</li>
<li><strong>保持并等待条件</strong>：一个线程持有一个资源，同时等待其他资源。</li>
<li><strong>不抢占条件</strong>：已经分配给线程的资源，在未完成使用之前，不能被其他线程抢占。</li>
<li><strong>循环等待条件</strong>：存在一线程资源循环等待的关系，即A线程等待B线程的资源，B线程等待C线程的资源，以此类推，形成一个等待闭环的关系。</li>
</ol>
<h4 id="4、线程之间的通信"><a href="#4、线程之间的通信" class="headerlink" title="4、线程之间的通信"></a><strong>4、线程之间的通信</strong></h4><ol>
<li>wait():   使当前线程进入等待状态，同时，释放锁。</li>
<li>notify(): 唤醒wait()优先级最高的线程，优先级相同则随机唤醒，被唤醒的线程从wait()的地方继续往下执行。</li>
<li>notifyAll();执行此方法，会唤醒所有正在等待的线程。</li>
</ol>
<p><strong>注意：</strong>这三个方法的使用，必须在同步代码块 或 同步方法中。</p>
<h3 id="第十一章-常用类与基础API"><a href="#第十一章-常用类与基础API" class="headerlink" title="第十一章: 常用类与基础API"></a>第十一章: 常用类与基础API</h3><p><strong>字符串的的不可变性：一但创建了字符串对象，其内容就不能被改变。</strong></p>
<pre><code class="highlight plaintext">String str1 = &quot;Hello&quot;;
String str2 = str1.concat(&quot;, World!&quot;);

// str1 仍然是 &quot;Hello&quot;
// str2 是一个新的字符串 &quot;Hello, World!&quot;</code></pre>



<p>p143：</p>
<pre><code class="highlight plaintext">String str = new String(&quot;helloworld!&quot;);   //在内存中创建了几个对象，</code></pre>

<p>一个是在堆空间中 new 的对象。 另一个是在字符串常量池中生命的字面量。</p>
<p><strong>String 和 StringBuilder、StringBuffer 的区别</strong></p>
<ul>
<li>String ：不可变，一但创建，内容无法更改，本身是线程安全的，适用于少量字符串操作内容固定的场景。</li>
<li>StringBuilder ： 可变，允许在原有的对象上进行修改，而不创建新的对象。不是线程安全的，适合单线程使用。使用于频繁的字符操作，如在循环内拼接字      符。</li>
<li>StringBuffer: 也可变，但是他是线程安全的。性能相对StringBuilder较低，因为它采用了同步机制。适合多线程环境。</li>
</ul>
<p><strong>String常用的API</strong></p>
<ol>
<li><p>boolean isEmpty():	 字符串是否为空</p>
</li>
<li><p>int  length():                      字符串长度</p>
</li>
<li><p>String concat(xx):             拼接</p>
</li>
<li><p>boolean equals(Object obj)    比较字符串是否相等，区分大小写</p>
</li>
<li><p>boolean equalsIgnoreCase(Object obj)   比较字符串是否相等，不区分大小写</p>
<p>。。。</p>
</li>
</ol>
<p>p147</p>
<p><strong>JDK8之前</strong></p>
<ul>
<li><strong>java.util.Date</strong> :  表示特定的时间，精确到毫秒。</li>
<li><strong>java.util.Calendar</strong> ： Calendar类是一个抽象类，提供了更多功能来处理时间和日期，例如设置字段，计算时间等。通常通过Calendar.getInstance方法来获取一个Calendar对象.</li>
<li><strong>SimpleDateFormat</strong>: 是一个用来格式化和解析时间的类。</li>
</ul>
<p>p148</p>
<p><strong>JDK8中新引入的</strong></p>
<p>java8中引入了新的时间API,主要存放在java.time包下</p>
<ul>
<li><p><strong>LocalDate</strong>：表示不带时区的日期（年、月、日）。</p>
</li>
<li><p><strong>LocalTime</strong>：表示不带时区的时间（小时、分钟、秒）。</p>
</li>
<li><p><strong>LocalDateTime</strong>：表示不带时区的日期和时间。</p>
</li>
<li><p><strong>ZonedDateTime</strong>：表示带时区的日期和时间。</p>
</li>
<li><p><strong>Instant</strong>：表示一个时间戳，精确到纳秒。</p>
</li>
<li><p><strong>Duration</strong>：表示两个时间点之间的时间长度。</p>
</li>
<li><p><strong>Period</strong>：表示两个日期之间的日期差异。</p>
</li>
</ul>
<p>p149</p>
<p><strong>Comparator接口实现自然排序</strong></p>
<ol>
<li>首先自定义一个实现comparator接口实现的类，然后重写compare方法定义排序逻辑</li>
<li>使用 Arrays.sort(),结合自定义的comparator来排序集合或数组。</li>
</ol>
<p>p150</p>
<p>Comparable实现定制排序</p>
<ol>
<li>创建类并实现comparable接口</li>
<li>创建CompareTo方法，定义比较逻辑</li>
<li>创建对象并添加到集合</li>
<li>使用 collections.sort()  排序</li>
</ol>
<h3 id="第十二章-集合框架"><a href="#第十二章-集合框架" class="headerlink" title="第十二章: 集合框架"></a>第十二章: 集合框架</h3><h4 id="1、集合的框架体系"><a href="#1、集合的框架体系" class="headerlink" title="1、集合的框架体系"></a>1、集合的框架体系</h4><p>Java集合框架体系(java.util包下)</p>
<pre><code class="highlight plaintext">java.util.Collection :存储单列数据
	├── 子接口: list： 存储有序的，可重复的数据
    		├── ArrayList、LinkList、Vector
    ├──子接口: set 存储无序的，不可重复的数据
    		├──HashSet、LinkHashSet、TreeSet
java.util.map 存储双列数据，保存具有映射关系的(key-value对)的集合
	├── HashMap、LinkHashMap、TreeMap</code></pre>

<p><strong>Collection接口及常用方法</strong></p>
<ul>
<li><p>JDKb不提供此接口的仍和直接实现，而是提供更集体的子接口(如:Set 和 List)</p>
</li>
<li><p><strong>常用方法：</strong></p>
<ol>
<li>add(E obj): 	添加元素到当前集合</li>
<li>addAll(Collection other):    添加other 集合中的所有元素到当前集合中</li>
<li>int size() :           获取当前集合中下实际存储的元素个数</li>
<li>boolean isEmpty():          判断当前集合是否是空集合</li>
<li>boolean contains(Object obj):      判段当前集合中是否有一个与obj对象 equals返回 true 的元素。</li>
<li>boolean containsAll(Collection coll): 判断coll集合中的元素是否在当前集合中都存在。</li>
<li>boolean equals(Object obj)  判断当前集合与obj是否相等。</li>
<li>void clear():    清空元素集合</li>
<li>boolean   remove(Object obj)：  从当前集合中删除第一个找到的与obj对象equals返回true的元素。</li>
<li>boolean  removeAll(Collection coll):    从当前集合中删除所有与coll 集合中相同的元素。</li>
<li>boolean  retainAll（Collection coll）:从当前集合中删除两个集合中不同的元素。</li>
<li>Object[] toArray()  返回包含当前集合中所有元素的数组</li>
<li>hasCode()   获取集合对象的哈希值</li>
<li>iterator():    返回迭代器对象，用于集合遍历</li>
</ol>
</li>
</ul>
<p><strong>迭代器</strong></p>
<p>Iterator对象称为迭代器,主要用来遍历 Collection 中的元素。Collection 接口继承了 java.lang.Iterable 接口，该接口有一个iterator()方法,所有继承了Collection接口的类都有一个iterator()方法。</p>
<p>**1.接口:**迭代器通常提供以下几个方法：</p>
<ul>
<li>hasNext() : 检查是否还有下一个元素。</li>
<li>next(): 返回下一个元素</li>
<li>remove() 删除迭代器返回的最后一个元素。</li>
</ul>
<pre><code class="highlight plaintext">import java.util.ArrayList;
import java.util.Iterator;

public class IteratorExample &#123;
    public static void main(String[] args) &#123;
        ArrayList&lt;String&gt; fruits = new ArrayList&lt;&gt;();
        fruits.add(&quot;苹果&quot;);
        fruits.add(&quot;香蕉&quot;);
        fruits.add(&quot;橙子&quot;);

        // 创建迭代器
        Iterator&lt;String&gt; iterator = fruits.iterator();

        // 使用迭代器遍历集合
        while (iterator.hasNext()) &#123;
            String fruit = iterator.next();
            System.out.println(fruit);
        &#125;
    &#125;
&#125;</code></pre>



<p><strong>foreach循环</strong></p>
<ul>
<li>foreach循环(也叫增强for循环) 是JDK5.0中定义的一个高级的for 循环，专门用来遍历数组和集合的。</li>
</ul>
<pre><code class="highlight plaintext">for (元素类型 变量 : 集合或数组) &#123;
    // 使用变量执行操作
&#125;</code></pre>



<h4 id="2、List接口及其主要实现类"><a href="#2、List接口及其主要实现类" class="headerlink" title="2、List接口及其主要实现类:"></a>2、<strong>List接口及其主要实现类:</strong></h4><ul>
<li><p>list 是一个有序的集合接口,允许元素重复。</p>
</li>
<li><p>主要实现类</p>
</li>
</ul>
<ol>
<li><p><strong>ArrayList:</strong></p>
<ul>
<li>特点：基于动态数组实现，线程不安全。</li>
<li>适用场景:  当你需要频繁的读取数据，而不关心删除和插入性能时。</li>
</ul>
<pre><code class="highlight plaintext">import java.util.ArrayList;
import java.util.List;

public class ArrayListExample &#123;
    public static void main(String[] args) &#123;
        List&lt;String&gt; list = new ArrayList&lt;&gt;();
        list.add(&quot;Apple&quot;);
        list.add(&quot;Banana&quot;);
        list.add(&quot;Cherry&quot;);

        System.out.println(&quot;List: &quot; + list);
        System.out.println(&quot;Element at index 1: &quot; + list.get(1));  // 输出 &quot;Banana&quot;
    &#125;
&#125;</code></pre>

<p><strong>Arraylist  实现线程安全的几种方式。</strong></p>
<p><strong>1）、</strong>使用collections工具类的synchronizedList() 方法。该方法返回一个同步的包装类。所有对列的操作的都会被同步，从而保证线程安全。</p>
<pre><code class="highlight plaintext">import java.util.*;

public class ThreadSafeArrayList &#123;
    public static void main(String[] args) &#123;
        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();
        List&lt;Integer&gt; syncList = Collections.synchronizedList(list);

        // 通过同步列表进行操作
        syncList.add(1);
        syncList.add(2);

        // 使用同步块进行遍历（遍历操作需要额外同步）
        synchronized (syncList) &#123;
            for (Integer i : syncList) &#123;
                System.out.println(i);
            &#125;
        &#125;
    &#125;
&#125;</code></pre>

<p><strong>注意：</strong></p>
<p><code>Collections.synchronizedList()</code> 返回的列表是线程安全的，但是在遍历时，你仍然需要手动使用 <code>synchronized</code> 块来保证操作的线程安全性。因为遍历过程中可能会发生其他线程的修改，导致并发问题。</p>
</li>
</ol>
<p><strong>2）、使用CopyOnWriteArrayList</strong>, 是包java.util.concurrent 包中一个线程安全的list 实现。使用了 “写时复制“（Copy-On-Write）的策略,在写操作（add(),move()）时会复制底层数组。因此每次写操作都是独立的避免了并发问题。</p>
<p>示例：</p>
   <pre><code class="highlight plaintext">import java.util.*;
import java.util.concurrent.*;

public class ThreadSafeArrayList &#123;
    public static void main(String[] args) &#123;
        List&lt;Integer&gt; list = new CopyOnWriteArrayList&lt;&gt;();

        // 多线程安全地添加元素
        list.add(1);
        list.add(2);

        // 直接进行遍历，无需额外同步
        for (Integer i : list) &#123;
            System.out.println(i);
        &#125;
    &#125;
&#125;</code></pre>

<p><strong>优点：</strong>对读操作非常友好，读取操作不需要同步。</p>
<p><strong>缺点：</strong>写操作性能较低，每次写操作都会创建一个新的数组。</p>
<p><strong>3）、使用Vector</strong>,vector 是一个线程安全的动态数组类，它通过对所有的方法加锁来确保线程安全。但由于性能较低，所以不推荐。</p>
   <pre><code class="highlight plaintext">import java.util.*;

public class ThreadSafeArrayList &#123;
    public static void main(String[] args) &#123;
        List&lt;Integer&gt; list = new Vector&lt;&gt;();

        // 线程安全的操作
        list.add(1);
        list.add(2);

        for (Integer i : list) &#123;
            System.out.println(i);
        &#125;
    &#125;
&#125;
</code></pre>



<p>4）、<strong>自己通过同步机制实现线程安全。</strong>使用synchronized 关键字同步共享关键部分。</p>
   <pre><code class="highlight plaintext">import java.util.*;

public class ThreadSafeArrayList &#123;
    private List&lt;Integer&gt; list = new ArrayList&lt;&gt;();

    public synchronized void add(Integer value) &#123;
        list.add(value);
    &#125;

    public synchronized Integer get(int index) &#123;
        return list.get(index);
    &#125;

    public synchronized void remove(int index) &#123;
        list.remove(index);
    &#125;

    public synchronized int size() &#123;
        return list.size();
    &#125;

    public synchronized void printList() &#123;
        for (Integer i : list) &#123;
            System.out.println(i);
        &#125;
    &#125;

    public static void main(String[] args) &#123;
        ThreadSafeArrayList threadSafeList = new ThreadSafeArrayList();
        threadSafeList.add(1);
        threadSafeList.add(2);
        threadSafeList.printList();
    &#125;
&#125;</code></pre>



<ol start="2">
<li><p><strong>linkedList</strong></p>
<ul>
<li>特点: 基于双向链表实现，支持在列表的两端进行高效的插入和删除操作。</li>
<li>适用场景: 当你需要在列表的两端插入&#x2F;删除元素时</li>
</ul>
<pre><code class="highlight plaintext">import java.util.LinkedList;
import java.util.List;

public class LinkedListExample &#123;
    public static void main(String[] args) &#123;
        List&lt;String&gt; list = new LinkedList&lt;&gt;();
        list.add(&quot;Apple&quot;);
        list.add(&quot;Banana&quot;);
        list.add(&quot;Cherry&quot;);

        System.out.println(&quot;List: &quot; + list);
        list.add(1, &quot;Orange&quot;);  // 在索引1处插入元素
        System.out.println(&quot;After insertion: &quot; + list);
    &#125;
&#125;
</code></pre>
</li>
<li><p><strong>Vector</strong></p>
</li>
</ol>
<p>​	基于动态数组实现，类似于Arraylis , linklist  ,不同的是Vector 线程安全的。</p>
<pre><code class="highlight plaintext">import java.util.Vector;

public class VectorExample &#123;
    public static void main(String[] args) &#123;
        // 创建一个初始容量为 3 的 Vector
        Vector&lt;String&gt; vector = new Vector&lt;&gt;(3);

        // 添加元素
        vector.add(&quot;Java&quot;);
        vector.add(&quot;Python&quot;);
        vector.add(&quot;C++&quot;);

        // 打印 Vector 内容
        System.out.println(&quot;Vector contents: &quot; + vector);

        // 获取元素
        System.out.println(&quot;Element at index 1: &quot; + vector.get(1));

        // 修改元素
        vector.set(1, &quot;JavaScript&quot;);

        // 删除元素
        vector.remove(&quot;C++&quot;);

        // 打印修改后的内容
        System.out.println(&quot;Updated Vector: &quot; + vector);

        // 确保容量至少为 10
        vector.ensureCapacity(10);

        // 查看 Vector 的大小
        System.out.println(&quot;Vector size: &quot; + vector.size());
    &#125;
&#125;
</code></pre>



<h4 id="3、Set接口及其主要实现类"><a href="#3、Set接口及其主要实现类" class="headerlink" title="3、Set接口及其主要实现类"></a>3、<strong>Set接口及其主要实现类</strong></h4><p>Collection 的子接口，没有提供额外的方法，不允许包含相同的元素，</p>
<ol>
<li><strong>HashSet</strong></li>
</ol>
<ul>
<li>简介：	基于 Hash 表实现，不保证元素的实现。</li>
<li>特点：        元素的存储不可预测，及插入顺序和取出顺序不一样。</li>
</ul>
<pre><code class="highlight plaintext">import java.util.HashSet;

public class HashSetExample &#123;
    public static void main(String[] args) &#123;
        HashSet&lt;String&gt; set = new HashSet&lt;&gt;();
        set.add(&quot;Java&quot;);
        set.add(&quot;Python&quot;);
        set.add(&quot;C++&quot;);
        set.add(&quot;Java&quot;);  // 重复元素，不会添加

        System.out.println(set);  // 输出： [Java, Python, C++]
    &#125;
&#125;</code></pre>

<p><strong>2.LinkedHashSet</strong></p>
<ul>
<li>简介： LinkedhashSet 是HashSet 的子类，内部使用链表来维护元素的插入顺序。因此，他比HashSet多了一个按差如插入顺序访问元素的功能。</li>
</ul>
<pre><code class="highlight plaintext">import java.util.LinkedHashSet;

public class LinkedHashSetExample &#123;
    public static void main(String[] args) &#123;
        LinkedHashSet&lt;String&gt; set = new LinkedHashSet&lt;&gt;();
        set.add(&quot;Java&quot;);
        set.add(&quot;Python&quot;);
        set.add(&quot;C++&quot;);
        set.add(&quot;Java&quot;);  // 重复元素，不会添加

        System.out.println(set);  // 输出： [Java, Python, C++]
    &#125;
&#125;</code></pre>

<p><strong>3.TreeSet</strong></p>
<ul>
<li><p>简介：TreeSet是基于TreeMap  实现的，使用红黑树来存储元素，因此元素自动按升序排列。</p>
</li>
<li><p>使用场景:  适用于需要有序元素的去重操作。</p>
</li>
</ul>
<pre><code class="highlight plaintext">import java.util.TreeSet;

public class TreeSetExample &#123;
    public static void main(String[] args) &#123;
        TreeSet&lt;Integer&gt; set = new TreeSet&lt;&gt;();
        set.add(5);
        set.add(2);
        set.add(8);
        set.add(1);
        set.add(5);  // 重复元素，不会添加

        System.out.println(set);  // 输出： [1, 2, 5, 8]
    &#125;
&#125;</code></pre>

<p><strong>比较与总结</strong></p>
<table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>HashSet</strong></th>
<th><strong>LinkedHashSet</strong></th>
<th><strong>TreeSet</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>存储顺序</strong></td>
<td>不保证顺序</td>
<td>保证插入顺序</td>
<td>按自然顺序或自定义顺序排序</td>
</tr>
<tr>
<td><strong>底层实现</strong></td>
<td>哈希表（<code>HashMap</code>）</td>
<td>哈希表 + 链表</td>
<td>红黑树</td>
</tr>
<tr>
<td><strong>是否允许 <code>null</code></strong></td>
<td>允许</td>
<td>允许</td>
<td>不允许</td>
</tr>
<tr>
<td><strong>时间复杂度（平均情况）</strong></td>
<td>O(1)</td>
<td>O(1)</td>
<td>O(log n)</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>无序去重，性能要求高</td>
<td>保证插入顺序，较少操作需要按顺序访问元素</td>
<td>有序去重，元素需要按顺序排列</td>
</tr>
</tbody></table>
<p><strong>总结</strong></p>
<ul>
<li>**<code>HashSet</code>**：最常用的实现，性能较好，但不保证元素顺序。</li>
<li>**<code>LinkedHashSet</code>**：在 <code>HashSet</code> 基础上保持了元素插入顺序，适合需要顺序的去重操作。</li>
<li>**<code>TreeSet</code>**：提供有序集合，元素按照自然顺序或自定义的比较规则排序，适合需要顺序且去重的场景，但不允许 <code>null</code> 元素。</li>
</ul>
<h4 id="4、Map接口及其主要实现类"><a href="#4、Map接口及其主要实现类" class="headerlink" title="4、Map接口及其主要实现类:"></a><strong>4、Map接口及其主要实现类:</strong></h4><p>双列集合，保存具有 key-value  映射关系的集合。</p>
<p><strong>Map接口常用方法</strong></p>
<p>(1)、Object put(Object key,Object value):	将指定的key-value 添加到当前map中</p>
<p>(2)、void putAll(Map m):     将m中所有的key_value  存放到当前的map中</p>
<p>(3)、Object remove(Object key):    移除指定的key的key-value 对，并返回value</p>
<p>(4)、void  clear():      清空当前map中所有的数据。</p>
<p>(5)、Object get(Object key):   获取指定key对应的value</p>
<p>。。。</p>
<p><strong>1）、HashMap</strong></p>
<ul>
<li><p>实现原理：JDK1.7： 数组 + 链表，JDK1.8 ：数组+ 链表 + 红黑树。是线程不安全的。</p>
</li>
<li><p>应用场景：适合需要快速查找，插入和删除，通常应用于大多数map普通的应用场景。</p>
</li>
</ul>
<pre><code class="highlight plaintext">import java.util.HashMap;
import java.util.Map;

public class HashMapExample &#123;
    public static void main(String[] args) &#123;
        Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;();
        map.put(&quot;apple&quot;, 3);
        map.put(&quot;banana&quot;, 2);
        map.put(&quot;orange&quot;, 4);

        System.out.println(map.get(&quot;banana&quot;));  // 输出：2
        System.out.println(map.containsKey(&quot;apple&quot;));  // 输出：true
    &#125;
&#125;</code></pre>

<p>面试题：<strong>hashmap  的 put 流程：</strong></p>
<p>(1)、**计算键的哈希值 (hash code)**：通过ke.hashCode() 获取哈希值。</p>
<p>(2)、<strong>定位桶位置</strong>: 通过哈希值定位桶的位置,<strong>得到bucketIndex</strong>。</p>
<p>(3)、<strong>处理冲突</strong>:</p>
<ul>
<li>如果桶为空，直接插入。</li>
<li>如果桶已经有元素，检查键是否存在于该桶中：<ul>
<li>如果存在，更新并返回旧值。</li>
<li>如果不存在，将新键值对插入链表(或红黑树中)。</li>
</ul>
</li>
</ul>
<p>(4)、<strong>检查负载因子</strong>：如果size 超过 负载因子 * 容量，触发扩容。</p>
<p>(5)、<strong>返回旧值</strong>: 如果是更新操作，返回旧值；如果是插入新元素 返回Null。</p>
<p><strong>示例：</strong></p>
<pre><code class="highlight plaintext">public V put(K key, V value) &#123;
    // 1. 计算键的哈希值
    int hash = hash(key);
    // 2. 计算桶索引
    int bucketIndex = (hash &amp; (table.length - 1));

    // 3. 获取桶中的元素
    Node&lt;K,V&gt; head = table[bucketIndex];
    
    // 4. 如果桶为空，直接插入
    if (head == null) &#123;
        table[bucketIndex] = new Node&lt;&gt;(hash, key, value, null);
        size++;
        return null;
    &#125;

    // 5. 处理哈希冲突（链表法）
    Node&lt;K,V&gt; current = head;
    while (current != null) &#123;
        if (current.hash == hash &amp;&amp; (current.key.equals(key))) &#123;
            // 更新值，返回旧值
            V oldValue = current.value;
            current.value = value;
            return oldValue;
        &#125;
        current = current.next;
    &#125;

    // 如果没有找到相同的键，插入新的键值对
    table[bucketIndex] = new Node&lt;&gt;(hash, key, value, head);
    size++;

    // 6. 检查负载因子，是否需要扩容
    if (size &gt;= threshold) &#123;
        resize();
    &#125;
    
    return null;
&#125;</code></pre>

<p><strong>hashmap：相关面试题</strong></p>
<ul>
<li><strong>HashMap怎么查找元素的呢？</strong></li>
</ul>
<p><strong>1）、计算哈希值：</strong>通过hashCode() 计算键的哈希值。</p>
<p><strong>2）、计算索引：</strong>通过哈希值和容量计算出数组的索引位置。</p>
<p><strong>3）、查找桶：</strong>查看该索引中的桶，如果为空，则查找失败。</p>
<p><strong>4）、处理碰撞：</strong>如果桶中有多个元素，逐个对比键。</p>
<p><strong>5）、返回值：</strong>找到对应的键，返回对应的值；没有找到返回null。</p>
<ul>
<li><strong>为什么哈希&#x2F;扰动函数能降hash碰撞？</strong></li>
</ul>
<p><strong>2）、LinkedHashMap</strong></p>
<ul>
<li>实现原理：LinkedHashMap 继承自HashMap,并且使用双向链表维护键值对的插入顺序或访问顺序。也是线程不安全的。</li>
<li>应用场景:适合需要保留插入顺序或访问顺序的应用</li>
</ul>
<pre><code class="highlight plaintext">import java.util.LinkedHashMap;
import java.util.Map;

public class LinkedHashMapExample &#123;
    public static void main(String[] args) &#123;
        Map&lt;String, Integer&gt; map = new LinkedHashMap&lt;&gt;();
        map.put(&quot;apple&quot;, 3);
        map.put(&quot;banana&quot;, 2);
        map.put(&quot;orange&quot;, 4);

        // 输出按插入顺序的键值对
        for (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) &#123;
            System.out.println(entry.getKey() + &quot;: &quot; + entry.getValue());
        &#125;
    &#125;
&#125;
</code></pre>

<p><strong>3）、TreeMap</strong></p>
<ul>
<li>实现原理：基于红黑树(白平衡二叉查找树)实现的 Map,也是线程不安全的。</li>
<li>应用场景:  适合需要按排序顺序访问为元素的场景</li>
</ul>
<pre><code class="highlight plaintext">import java.util.Map;
import java.util.TreeMap;

public class TreeMapExample &#123;
    public static void main(String[] args) &#123;
        Map&lt;String, Integer&gt; map = new TreeMap&lt;&gt;();
        map.put(&quot;apple&quot;, 3);
        map.put(&quot;banana&quot;, 2);
        map.put(&quot;orange&quot;, 4);

        // 输出按键的字典顺序排序的键值对
        for (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) &#123;
            System.out.println(entry.getKey() + &quot;: &quot; + entry.getValue());
        &#125;
    &#125;
&#125;</code></pre>

<p><strong>4）、HashTable</strong></p>
<ul>
<li>实现原理：是早期的哈希表实现，类似于Hashmap,但是它是线程安全的。所有的方法都被同步。</li>
<li>应用场景:主要用于一些老旧的应用。</li>
</ul>
<pre><code class="highlight plaintext">import java.util.Hashtable;
import java.util.Map;

public class HashtableExample &#123;
    public static void main(String[] args) &#123;
        Map&lt;String, Integer&gt; map = new Hashtable&lt;&gt;();
        map.put(&quot;apple&quot;, 3);
        map.put(&quot;banana&quot;, 2);
        map.put(&quot;orange&quot;, 4);

        System.out.println(map.get(&quot;banana&quot;));  // 输出：2
    &#125;
&#125;</code></pre>

<p><strong>总结</strong></p>
<table>
<thead>
<tr>
<th>类名</th>
<th>描述</th>
<th>线程安全性</th>
<th>排序</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td><code>HashMap</code></td>
<td>基于哈希表的 <code>Map</code> 实现，支持 <code>null</code> 键和值</td>
<td>非线程安全</td>
<td>无序</td>
<td>普通的 <code>Map</code> 操作，适合快速查找、插入和删除</td>
</tr>
<tr>
<td><code>LinkedHashMap</code></td>
<td><code>HashMap</code> 的子类，保持插入顺序或访问顺序</td>
<td>非线程安全</td>
<td>按插入&#x2F;访问顺序</td>
<td>保留插入顺序或访问顺序，适合缓存实现等</td>
</tr>
<tr>
<td><code>TreeMap</code></td>
<td>基于红黑树的 <code>Map</code> 实现，按键的自然顺序或自定义排序顺序排列</td>
<td>非线程安全</td>
<td>有序</td>
<td>需要排序的 <code>Map</code>，如字典、范围查找等</td>
</tr>
<tr>
<td><code>Hashtable</code></td>
<td>早期的哈希表实现，所有方法都被同步</td>
<td>线程安全</td>
<td>无序</td>
<td>老旧的线程安全 <code>Map</code>，性能较差，现多用 <code>ConcurrentHashMap</code> 替代</td>
</tr>
<tr>
<td><code>ConcurrentHashMap</code></td>
<td>线程安全的哈希表实现，采用分段锁保证并发性能</td>
<td>线程安全</td>
<td>无序</td>
<td>高并发环境下的线程安全 <code>Map</code>，适用于多线程共享数据等场景</td>
</tr>
</tbody></table>
<ul>
<li><p>对于 <strong>普通用途</strong>，一般使用 <code>HashMap</code>。</p>
</li>
<li><p>如果需要 <strong>保持插入顺序</strong> 或 <strong>访问顺序</strong>，使用 <code>LinkedHashMap</code>。</p>
</li>
<li><p>如果需要 <strong>按键排序</strong>，使用 <code>TreeMap</code>。</p>
</li>
<li><p>如果需要 <strong>线程安全</strong>，推荐使用 <code>ConcurrentHashMap</code>（而不是 <code>Hashtable</code>）</p>
</li>
</ul>
<p><strong>Collections工具类</strong></p>
<p>collections工具类中提供了一系列静态的方法对集合元素进行排序，查询和修改等操作。</p>
<p>p155</p>
<p><strong>list接口常用方法的测试</strong></p>
<p>增:</p>
<p>​	add(Object   obj);</p>
<p>​	addAll(Collection coll );</p>
<p>删：</p>
<p>​	remove(Object obj);</p>
<p>​	remove(int index)；</p>
<p>改：</p>
<p>​	set(int Index,Object obj);</p>
<p>查：</p>
<p>​	get(int Index)；</p>
<p>插入:</p>
<p>​	add(int Index,Object ele);</p>
<p>​	addAll(int Index,Collection eles)</p>
<p>长度;</p>
<p>​	size()</p>
<p>遍历:</p>
<p>​	iterator():  使用迭代器遍历;</p>
<p>​	增强for循环</p>
<p>​	一般 for() 循环</p>
<p>p156</p>
<pre><code class="highlight plaintext">java.util.Collection
		|---子接口 List 存储有序的,可重复的数据。(&quot;动态&quot;数组)
			|---ArrayList: List 的主要实现类,线程不安全的，效率高。底层使用object[]存储.
			|---Vector: list 的古老实现类,线程安全的，效率低。底层使用object[]存储.
			|---LinkList: 底层使用双向链表的方式进行存储。</code></pre>

<p><strong>集合排序的实现方案:</strong></p>
<ol>
<li><p><strong>使用Comparable 接口排序</strong></p>
<p>实现Comparable接口，重写comparTo()方法 。CompareTo()的返回值是:</p>
<p><strong>负数</strong>：当前对象小于 <code>o</code>。</p>
<p><strong>0</strong>：当前对象等于 <code>o</code>。</p>
<p><strong>正数</strong>：当前对象大于 <code>o</code>。</p>
</li>
</ol>
<p>当一个类实现了Comparable 接口后，使用Collection.sort() 或 Arrays.sort() 就可以直接进行排序。</p>
<pre><code class="highlight plaintext">import java.util.*;

class Person implements Comparable&lt;Person&gt; &#123;
    private String name;
    private int age;

    public Person(String name, int age) &#123;
        this.name = name;
        this.age = age;
    &#125;

    public int getAge() &#123;
        return age;
    &#125;

    @Override
    public int compareTo(Person other) &#123;
        return Integer.compare(this.age, other.age);  // 按年龄升序排列
    &#125;

    @Override
    public String toString() &#123;
        return name + &quot; (&quot; + age + &quot;)&quot;;
    &#125;

    public static void main(String[] args) &#123;
        List&lt;Person&gt; people = new ArrayList&lt;&gt;();
        people.add(new Person(&quot;Alice&quot;, 30));
        people.add(new Person(&quot;Bob&quot;, 25));
        people.add(new Person(&quot;Charlie&quot;, 35));

        // 使用 Collections.sort() 排序
        Collections.sort(people);

        System.out.println(&quot;Sorted by age: &quot; + people);
    &#125;
&#125;</code></pre>

<p><strong>2.使用Comparator接口排序</strong></p>
<p>Comparator接口提供了一个方法</p>
<pre><code class="highlight plaintext">int compare(T o1, T o2);</code></pre>

<ul>
<li><p>如果返回负数，表示 <code>o1</code> 小于 <code>o2</code>；</p>
</li>
<li><p>如果返回 0，表示 <code>o1</code> 等于 <code>o2</code>；</p>
</li>
<li><p>如果返回正数，表示 <code>o1</code> 大于 <code>o2</code>。</p>
</li>
</ul>
<p>通常我们在自定义的Comparator类中实现compare方法,并将其传递给排序方法( Collections.sort() 或者 Arrays.sort() )进行排序。</p>
<pre><code class="highlight plaintext">import java.util.*;

class Person &#123;
    private String name;
    private int age;

    public Person(String name, int age) &#123;
        this.name = name;
        this.age = age;
    &#125;

    public String getName() &#123;
        return name;
    &#125;

    public int getAge() &#123;
        return age;
    &#125;

    @Override
    public String toString() &#123;
        return name + &quot; (&quot; + age + &quot;)&quot;;
    &#125;

    public static void main(String[] args) &#123;
        List&lt;Person&gt; people = new ArrayList&lt;&gt;();
        people.add(new Person(&quot;Alice&quot;, 30));
        people.add(new Person(&quot;Bob&quot;, 25));
        people.add(new Person(&quot;Charlie&quot;, 35));

        // 按年龄升序排序
        Comparator&lt;Person&gt; ageComparator = new Comparator&lt;Person&gt;() &#123;
            @Override
            public int compare(Person p1, Person p2) &#123;
                return Integer.compare(p1.getAge(), p2.getAge());
            &#125;
        &#125;;
        Collections.sort(people, ageComparator);
        System.out.println(&quot;Sorted by age: &quot; + people);

        // 按名字字母升序排序
        Comparator&lt;Person&gt; nameComparator = new Comparator&lt;Person&gt;() &#123;
            @Override
            public int compare(Person p1, Person p2) &#123;
                return p1.getName().compareTo(p2.getName());
            &#125;
        &#125;;
        Collections.sort(people, nameComparator);
        System.out.println(&quot;Sorted by name: &quot; + people);
    &#125;
&#125;</code></pre>





<h3 id="第十三章-泛型"><a href="#第十三章-泛型" class="headerlink" title="第十三章: 泛型"></a>第十三章: 泛型</h3><p><strong>1、泛型的概念</strong></p>
<p>泛型是一种设计概念,允许你编写时可以处理多种数据类型的代码。它使得类，函数，接口可以使用类型参数，从而在运行时确定具体的数据类型，而不在编写时候就确定具体的数据类型。</p>
<p>例如：</p>
<pre><code class="highlight plaintext">public class Box&lt;T&gt; &#123;
    private T item;

    public void setItem(T item) &#123;
        this.item = item;
    &#125;

    public T getItem() &#123;
        return item;
    &#125;
&#125;</code></pre>

<p>在这个例子中，<code>Box</code>类使用了一个类型参数<code>T</code>，这意味着你可以创建一个<code>Box</code>对象来存储任意类型的对象，比如<code>Box&lt;Integer&gt;</code>或<code>Box&lt;String&gt;</code>。</p>
<p><strong>2、为什么要有泛型</strong></p>
<p>解决获取元素时，需要做类型转换的问题，例如 在集合中有泛型时，只有指定的元素类型才能添加到集合中。保证了类型安全。</p>
<p><strong>3、自定义泛型结构</strong></p>
<p>3.1常用范型结构自定义</p>
<p>3.1 .1自定义泛型类</p>
<pre><code class="highlight plaintext">public class GenericBox&lt;T&gt; &#123;
    private T item;
	
    public T getItem() &#123;
        return item;
    &#125;

    public void setItem(T item) &#123;
        this.item = item;
    &#125;

&#125;</code></pre>

<p>3.1.2 自定义泛型方法</p>
<pre><code class="highlight plaintext">public class GenericMethodExample &#123;
    // 泛型方法
    public static &lt;T&gt; void printArray(T[] array) &#123;
        for (T element : array) &#123;
            System.out.println(element);
        &#125;
    &#125;

    public static void main(String[] args) &#123;
        Integer[] intArray = &#123;1, 2, 3, 4, 5&#125;;
        String[] strArray = &#123;&quot;Hello&quot;, &quot;World&quot;&#125;;

        System.out.println(&quot;Integer Array:&quot;);
        printArray(intArray); // 调用泛型方法

        System.out.println(&quot;String Array:&quot;);
        printArray(strArray); // 调用泛型方法
    &#125;
&#125;</code></pre>

<p>3.1.3 自定义多参数泛型类</p>
<pre><code class="highlight plaintext">public class GenericPair&lt;K, V&gt; &#123;
    private K key;
    private V value;

    public GenericPair(K key, V value) &#123;
        this.key = key;
        this.value = value;
    &#125;

&#125;</code></pre>

<p>3.1.4 自定义泛型接口</p>
<pre><code class="highlight plaintext">// 定义一个泛型接口
public interface GenericInterface&lt;T&gt; &#123;
    void performAction(T item);
&#125;

// 实现该接口
public class StringAction implements GenericInterface&lt;String&gt; &#123;
    @Override
    public void performAction(String item) &#123;
        System.out.println(&quot;Processing string: &quot; + item);
    &#125;
&#125;</code></pre>



<h3 id="第十五章：File类与IO流"><a href="#第十五章：File类与IO流" class="headerlink" title="第十五章：File类与IO流"></a>第十五章：File类与IO流</h3><p>在 Java 中，**<code>File</code> 类<strong>和</strong>I&#x2F;O 流（Input&#x2F;Output Streams）**是处理文件和数据输入输出的重要工具。<code>File</code> 类用于文件和目录的操作，而 I&#x2F;O 流用于读写文件内容以及在程序和外部设备之间传输数据。</p>
<p><strong>1. <code>File</code> 类</strong></p>
<p><code>File</code> 类是位于 <code>java.io</code> 包中的一个重要类，它提供了一些方法来操作文件和目录。通过 <code>File</code> 类，可以进行以下操作：</p>
<ul>
<li><strong>创建、删除文件和目录</strong></li>
<li><strong>检查文件或目录的属性</strong></li>
<li><strong>获取文件的基本信息（如路径、大小、修改日期等）</strong></li>
<li><strong>列出目录中的文件</strong></li>
</ul>
<p><strong>1.1 创建 <code>File</code> 对象</strong></p>
<p><code>File</code> 类的构造方法主要有两种形式：</p>
<ul>
<li><code>File(String pathname)</code>：通过路径字符串创建 <code>File</code> 对象。</li>
<li><code>File(String parent, String child)</code>：通过父目录路径和子文件名创建 <code>File</code> 对象。</li>
<li><code>File(File parent, String child)</code>：通过父 <code>File</code> 对象和子文件名创建 <code>File</code> 对象。</li>
</ul>
<pre><code class="highlight plaintext">java复制代码import java.io.File;

public class FileExample &#123;
    public static void main(String[] args) &#123;
        // 创建 File 对象
        File file = new File(&quot;example.txt&quot;);

        // 判断文件是否存在
        if (file.exists()) &#123;
            System.out.println(&quot;File exists.&quot;);
        &#125; else &#123;
            System.out.println(&quot;File does not exist.&quot;);
        &#125;
    &#125;
&#125;</code></pre>

<p><strong>1.2 文件的常见操作</strong></p>
<ul>
<li><p><strong>判断文件是否存在</strong></p>
<pre><code class="highlight plaintext">file.exists(); // 如果文件存在返回 true，否则返回 false</code></pre>
</li>
<li><p><strong>创建文件</strong></p>
<pre><code class="highlight plaintext">file.createNewFile();  // 如果文件不存在，创建文件，返回 true；如果已存在，返回 false
</code></pre>
</li>
<li><p><strong>删除文件</strong></p>
<pre><code class="highlight plaintext">file.delete();  // 删除文件，成功返回 true，失败返回 false</code></pre>
</li>
<li><p><strong>判断是否是目录或文件</strong></p>
<pre><code class="highlight plaintext">java复制代码file.isDirectory();  // 判断是否是目录
file.isFile();       			// 判断是否是文件</code></pre>
</li>
<li><p><strong>获取文件或目录的路径</strong></p>
<pre><code class="highlight plaintext">java复制代码file.getAbsolutePath();  // 获取文件的绝对路径
file.getPath();          // 获取文件的相对路径
file.getName();          // 获取文件名</code></pre>
</li>
<li><p><strong>列出目录中的文件</strong></p>
<pre><code class="highlight plaintext">java复制代码File dir = new File(&quot;someDirectory&quot;);
String[] files = dir.list(); // 返回目录中的文件和子目录的文件名
File[] fileList = dir.listFiles(); // 返回目录中的文件和子目录的 File 对象</code></pre>
</li>
<li><p><strong>获取文件大小和修改时间</strong></p>
<pre><code class="highlight plaintext">java复制代码long fileSize = file.length();  // 获取文件的大小（字节）
long lastModified = file.lastModified();  // 获取文件的最后修改时间</code></pre></li>
</ul>
<ol start="2">
<li><strong>I&#x2F;O 流</strong></li>
</ol>
<p>Java 提供了两类 I&#x2F;O 流：</p>
<ol>
<li><strong>字节流（Byte Stream）</strong>：用于处理所有类型的 I&#x2F;O（包括二进制数据，如图片、音频文件等），每次读取或写入一个字节。</li>
<li><strong>字符流（Character Stream）</strong>：专门用于处理文本数据（字符），每次读取或写入一个字符。</li>
</ol>
<p>I&#x2F;O 流有两个主要的子类：</p>
<ul>
<li><strong>输入流（InputStream）</strong> 和 <strong>输出流（OutputStream）</strong>：字节流</li>
<li><strong>Reader</strong> 和 <strong>Writer</strong>：字符流</li>
</ul>
<p><strong>3. 字节流（Byte Streams）</strong></p>
<p>字节流可以处理所有类型的 I&#x2F;O 数据，包括字符数据、二进制数据等。字节流的根类是 <code>InputStream</code>（输入流）和 <code>OutputStream</code>（输出流）。</p>
<p><strong>3.1 <code>InputStream</code> 类及其常用子类</strong></p>
<ul>
<li>**<code>FileInputStream</code>**：用于从文件中读取字节数据。</li>
<li>**<code>BufferedInputStream</code>**：提供缓冲功能，提高读操作效率。</li>
</ul>
<pre><code class="highlight plaintext">java复制代码import java.io.FileInputStream;
import java.io.IOException;

public class FileInputStreamExample &#123;
    public static void main(String[] args) &#123;
        try (FileInputStream fis = new FileInputStream(&quot;example.txt&quot;)) &#123;
            int data;
            while ((data = fis.read()) != -1) &#123;
                System.out.print((char) data);  // 打印文件内容
            &#125;
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;</code></pre>



<p><strong>3.2 <code>OutputStream</code> 类及其常用子类</strong></p>
<ul>
<li>**<code>FileOutputStream</code>**：用于向文件中写入字节数据。</li>
<li>**<code>BufferedOutputStream</code>**：提供缓冲功能，提高写操作效率。</li>
</ul>
<pre><code class="highlight plaintext">java复制代码import java.io.FileOutputStream;
import java.io.IOException;

public class FileOutputStreamExample &#123;
    public static void main(String[] args) &#123;
        try (FileOutputStream fos = new FileOutputStream(&quot;example.txt&quot;)) &#123;
            fos.write(&quot;Hello, Java!&quot;.getBytes());
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;</code></pre>



<ol start="4">
<li><strong>字符流（Character Streams）</strong></li>
</ol>
<p>字符流用于处理文本数据（字符）。字符流的根类是 <code>Reader</code> 和 <code>Writer</code>，它们处理的是字符，而非字节。</p>
<p><strong>4.1 <code>Reader</code> 类及其常用子类</strong></p>
<ul>
<li>**<code>FileReader</code>**：用于从文件中读取字符数据。</li>
<li>**<code>BufferedReader</code>**：提供缓冲功能，常用于读取字符文件和处理文本行。</li>
</ul>
<pre><code class="highlight plaintext">java复制代码import java.io.FileReader;
import java.io.BufferedReader;
import java.io.IOException;

public class FileReaderExample &#123;
    public static void main(String[] args) &#123;
        try (BufferedReader br = new BufferedReader(new FileReader(&quot;example.txt&quot;))) &#123;
            String line;
            while ((line = br.readLine()) != null) &#123;
                System.out.println(line);  // 打印文件的每一行
            &#125;
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;</code></pre>



<p><strong>4.2 <code>Writer</code> 类及其常用子类</strong></p>
<ul>
<li>**<code>FileWriter</code>**：用于向文件写入字符数据。</li>
<li>**<code>BufferedWriter</code>**：提供缓冲功能，提高写入效率。</li>
</ul>
<pre><code class="highlight plaintext">java复制代码import java.io.FileWriter;
import java.io.BufferedWriter;
import java.io.IOException;

public class FileWriterExample &#123;
    public static void main(String[] args) &#123;
        try (BufferedWriter bw = new BufferedWriter(new FileWriter(&quot;example.txt&quot;))) &#123;
            bw.write(&quot;Hello, World!&quot;);
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;</code></pre>



<ol start="5">
<li><strong>标准输入输出</strong></li>
</ol>
<p>Java 提供了对标准输入输出的支持，即控制台的输入输出。</p>
<ul>
<li>**<code>System.in</code>**：标准输入流，通常用作接收用户输入。</li>
<li>**<code>System.out</code>**：标准输出流，通常用于打印输出到控制台。</li>
</ul>
<p><strong>5.1 使用 <code>System.in</code> 读取输入</strong></p>
<pre><code class="highlight plaintext">java复制代码import java.io.IOException;

public class ConsoleInputExample &#123;
    public static void main(String[] args) throws IOException &#123;
        System.out.println(&quot;Enter a character: &quot;);
        int data = System.in.read();  // 读取一个字符
        System.out.println(&quot;You entered: &quot; + (char) data);
    &#125;
&#125;</code></pre>



<p><strong>5.2 使用 <code>System.out</code> 输出数据</strong></p>
<pre><code class="highlight plaintext">java复制代码public class ConsoleOutputExample &#123;
    public static void main(String[] args) &#123;
        System.out.println(&quot;Hello, World!&quot;);
    &#125;
&#125;</code></pre>



<p><strong>6. I&#x2F;O 缓冲流（Buffered Streams）</strong></p>
<p><code>BufferedReader</code> 和 <code>BufferedWriter</code> 是对字符流的增强，它们通过缓冲区来提高 I&#x2F;O 操作的效率。在字节流中，<code>BufferedInputStream</code> 和 <code>BufferedOutputStream</code> 扮演类似角色。</p>
<p><strong>6.1 缓冲字符流示例</strong></p>
<pre><code class="highlight plaintext">java复制代码import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;

public class BufferedReaderExample &#123;
    public static void main(String[] args) &#123;
        try (BufferedReader br = new BufferedReader(new FileReader(&quot;example.txt&quot;))) &#123;
            String line;
            while ((line = br.readLine()) != null) &#123;
                System.out.println(line);
            &#125;
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;</code></pre>



<ol start="7">
<li><strong>文件复制</strong></li>
</ol>
<p>下面是一个常见的文件复制操作示例，利用字节流和缓冲流。</p>
<pre><code class="highlight plaintext">java复制代码import java.io.*;

public class FileCopyExample &#123;
    public static void main(String[] args) &#123;
        try (FileInputStream fis = new FileInputStream(&quot;source.txt&quot;);
             FileOutputStream fos = new FileOutputStream(&quot;destination.txt&quot;);
             BufferedInputStream bis = new BufferedInputStream(fis);
             BufferedOutputStream bos = new BufferedOutputStream(fos)) &#123;
             
            int byteData;
            while ((byteData = bis.read()) != -1) &#123;
                bos.write(byteData);
            &#125;
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;</code></pre>

<ol start="8">
<li><strong>总结</strong></li>
</ol>
<ul>
<li><strong><code>File</code> 类</strong>：用于文件和目录的操作</li>
</ul>
<p>​</p>
<h3 id="第十七章：反射"><a href="#第十七章：反射" class="headerlink" title="第十七章：反射"></a>第十七章：反射</h3><p><strong>1、反射的概念:</strong></p>
<p>​	在类加载完后，会在堆内存中生成一个 Class 对象，这个对象包含了类所有的结构信息。这个对象就像是一个镜子，通过这个镜子可以看到类的所有信息。所以，我们形象的称之为反射。</p>
<p><strong>2、Class类</strong></p>
<p>​	在 Object 中定义了一个方法，public final  class getClass();  这个方法将会被所有的子类继承。这个方法的返回值是一个Class类。</p>
<p><strong>3、Object类，Class类、普通类的关系图：</strong></p>
<pre><code class="highlight plaintext">                         +-------------------+
                         |       Object      |  (所有类的祖先类)
                         +-------------------+
                           |               |
     +---------------------+               +---------------------+
     |                                                       |
+------------+                                           +-------------+
|   Class    |  (表示类的类)                            |    MyClass   |  (普通类)
+------------+                                           +-------------+
     |                                                       |
     +----------------------------+--------------------------+
                                  |
                             +------------+
                             |   Class&lt;?&gt; |  (描述具体类的 Class 对象)
                             +------------+
</code></pre>



<p>（1）、**<code>Object</code>类** 是所有Java类的祖先类（根类）。任何一个普通的Java类（例如 <code>MyClass</code>）都默认继承自<code>Object</code>类（除非它显式继		承其他类）。<code>Object</code>类提供了很多核心方法，比如 <code>toString()</code>、<code>equals()</code>、<code>hashCode()</code> 等，所有类都可以继承这些方		法。</p>
<p>（2）、**<code>Class</code>类** 是所有类的元数据类，它本身也是一个普通的Java类，继承自<code>Object</code>类。<strong>每一个Java类都有一个与之相关联的<code>Class</code>		对象。</strong>通过<code>Class</code>对象，我们可以在运行时查询类的信息（如类的方法、字段等），并通过反射来动态操作类的实例。</p>
<p>（3）、**<code>MyClass</code>（普通类）** 是一个开发人员定义的普通类。它继承自<code>Object</code>类（隐式），并且在JVM中有一个对应的<code>Class</code>对象。通		过反射机制，可以通过<code>Class</code>类的API来操作<code>MyClass</code>的实例。</p>
<p>（4）、**<code>Class&lt;?&gt;</code>对象** 对应于类的元数据。每个类（如<code>MyClass</code>）都与一个<code>Class</code>对象相关联，<code>Class</code>对象存储了类的结构信息（如构		造方法、字段、方法等）。反射通过<code>Class</code>对象获取类的相关信息，并能够动态地创建类的实例或调用类的方法。</p>
<p>4、获取 Class 实例对象的四种方式</p>
<pre><code class="highlight plaintext">//1、调用运行时类的静态属性
 Class cls1 = Person.class;
 System.out.println(cls1);
 
 //2、调用运行时对象的 getClass
 Person p2 = new Person();
 Class cls2 = p2.getClass();

 //3、调用 Class 的静态方法  forName;(常用)
 String className = new String(&quot;com.atguigu&quot;);
 Class cls3 = Class.forName(className);

//4、使用类的加载器的方式(了解)
Class cls4 = ClassLoader.getSystemClassLoader().loadClass(com.atguigu);</code></pre>



<p><strong>5、反射的基本应用：</strong></p>
<p>有了class 对象，可以做什么？</p>
<p><strong>5.1、应用一	 ——— 	创建运行时类的对象</strong></p>
<ul>
<li><p><strong>方式一：直接调用 Class 的 newInstance();</strong></p>
<p>要 求： 1）类必须有一个无参数的构造器。2）类的构造器的访问权限需要足够。</p>
</li>
<li><p><strong>方式2：通过获取构造器对象来进行实例化</strong></p>
</li>
</ul>
<p><strong>5.2、应用二	——— 	获取运行时类的完整结构</strong></p>
<p>可以获取：包、修饰符、类型名、父类（包括泛型父类）、父接口（包括泛型父接口）、成员（属性、构造器、方法）、注解（类上的、方法上的、属性上的）。</p>
<p><strong>5.3、应用三	———	调用运行时类的指定结构</strong></p>
<p>(1)、获取该类型的 Class 对象</p>
<p>Class cls &#x3D; Class.forName();</p>
<p>(2)、获取方法对象</p>
<p>Method met &#x3D; class.getDeclareMethod(“方法名，”方法的形参类型列表);</p>
<p>(3)、创建实例对象</p>
<p>object obj &#x3D; clazz.newInstance();</p>
<p>(4)、调用方法</p>
<p>Object result &#x3D;method.invoke(obj,方法的实参列表);</p>
<p><strong>5.4、应用四	———	读取注解信息</strong></p>
<p>一个完整的注解因该包含三个部分：(1)、声明	(2)、使用	(3)、读取</p>
<h4 id="常见面试题解答"><a href="#常见面试题解答" class="headerlink" title="常见面试题解答:"></a>常见面试题解答:</h4><ol>
<li><p>为什么需要克隆？如何实现对象的克隆? 深浅拷贝的区别？</p>
<p><strong>克隆:克隆是指创建一个对象的副本，通常通过复制一个对象的属性来生成一个新的对象，新的对象和原对象是两个不同的实例。(1)通过对对象的克隆,可以实现数据的备份；通过克隆对现象而不是新建对象，可以提高性能。(2)使用Oject的clone()方法，同时还要实现cloneable接口。(3)浅拷贝只能备份基本数据类型，引用数据类型克隆的仍然是地址，修改克隆对象的引应用数据类型会影响到原对象;深拷贝则是完整的拷贝原对象，修改引用数据的成员不会影响到原对象。需要重写clone()方法。</strong></p>
</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://xz613.github.io">John Doe</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://xz613.github.io/2025/03/11/JavaSE/">https://xz613.github.io/2025/03/11/JavaSE/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://xz613.github.io" target="_blank">他乡遇故知</a>！</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="/img/avator.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.4/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.4/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/03/11/git%E5%9F%BA%E7%A1%80/" title="git基础"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">git基础</div></div><div class="info-2"><div class="info-item-1"> title: git基础date: 2024-07-22 14:02:48tags:  Git基础篇及一些常用指令1、Git的一些基础 分布式：每个人的计算机都有一个完整的代码仓库，包括所有的版本历史。使得开发者可以在离线的情况下进行工作。 仓库(Repository)：存储项目文件和版本历史的地方，可以是本地仓库或者远程仓库。 工作区(Working Directory)：当前正在编辑的文件所在的目录。 暂存区(Staging Area)：用于暂时保存提交文件的区域。 提交(Commit)：将暂存区的文件提交到本地仓库的操作，每次提交都一个唯一的标识，哈希。 分支(Branch):用于并行开发的独立线，主分支通常是main 或 master。 远程仓库(Remoe Repository)：托管在服务器上的仓库，语序团队成员之间共享代码。  2、Git常用指令 git config  –global user.name 用户名 添加仓库用户名  git config –global user.email 邮箱 设置用户邮箱  git init 初始化仓库  git add...</div></div></div></a><a class="pagination-related" href="/2025/03/11/MySQL%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" title="MySQL基础知识"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">MySQL基础知识</div></div><div class="info-2"><div class="info-item-1">第二章: 查询语句参考链接：MySQL LIKE 用法与实例 1.the  SELECT 后跟表中的列，多个列用逗号隔开； 检查所有列，使用*; 分号 ； 表示语句的结束。  将SQL关键字大写是一个好的习惯。但是，SQL是不区分到小写的。 SELECT columns_list FROM table_name;    2.WHERE 子句WHERE 子句允许允许您为  SELECT   指定查询的条件。 语法如下： SELECT     * FROM     actor WHERE     last_name = &#x27;ALLEN&#x27;     3.AND、OR、NOT 运算符 AND:  双目逻辑运算符，只有当两个操作数都为真时，结果才返回真，否则返回假或者 NULL。   运算优先级高于OR a AND b  OR: 双目逻辑运算符，两个操作数至少有一个为TRUE(1),结果都返回TRUE；如果一个操作数为null，另一个为0,则运算的结果也为NULL。 SELECT 0 OR...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/avator.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">John Doe</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">9</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>关注我</span></a><div class="card-info-social-icons"><a class="social-icon" href="/13048559773@163.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">这是我的博客</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9AJava%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">第一章：Java语言概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%9A%E5%8F%98%E9%87%8F%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">2.</span> <span class="toc-text">第二章：变量与运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%9A%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5"><span class="toc-number">3.</span> <span class="toc-text">第三章：流程控制语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0%EF%BC%9A%E6%95%B0%E7%BB%84"><span class="toc-number">4.</span> <span class="toc-text">第五章：数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0%EF%BC%9A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%9F%BA%E7%A1%80"><span class="toc-number">5.</span> <span class="toc-text">第六章：面向对象(基础)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0%EF%BC%9A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E8%BF%9B%E9%98%B6"><span class="toc-number">6.</span> <span class="toc-text">第七章：面向对象(进阶)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E5%85%AB%E7%AB%A0%EF%BC%9A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E9%AB%98%E7%BA%A7"><span class="toc-number">7.</span> <span class="toc-text">第八章：面向对象(高级)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E6%98%8E%EF%BC%9A"><span class="toc-number">7.1.</span> <span class="toc-text">说明：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B9%9D%E7%AB%A0%EF%BC%9A%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">8.</span> <span class="toc-text">第九章：异常处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E7%AB%A0%EF%BC%9A%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">9.</span> <span class="toc-text">第十章：多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%E2%80%94%E7%A8%8B%E5%BA%8F%EF%BC%8C%E8%BF%9B%E7%A8%8B%EF%BC%8C%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%EF%BC%8C%E5%B9%B6%E8%A1%8C%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">9.1.</span> <span class="toc-text">1、多线程—程序，进程，线程与并发，并行的概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F"><span class="toc-number">9.2.</span> <span class="toc-text">2、多线程，线程的创建方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="toc-number">9.3.</span> <span class="toc-text">3、线程安全问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1"><span class="toc-number">9.4.</span> <span class="toc-text">4、线程之间的通信</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-%E5%B8%B8%E7%94%A8%E7%B1%BB%E4%B8%8E%E5%9F%BA%E7%A1%80API"><span class="toc-number">10.</span> <span class="toc-text">第十一章: 常用类与基础API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6"><span class="toc-number">11.</span> <span class="toc-text">第十二章: 集合框架</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E9%9B%86%E5%90%88%E7%9A%84%E6%A1%86%E6%9E%B6%E4%BD%93%E7%B3%BB"><span class="toc-number">11.1.</span> <span class="toc-text">1、集合的框架体系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81List%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%85%B6%E4%B8%BB%E8%A6%81%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="toc-number">11.2.</span> <span class="toc-text">2、List接口及其主要实现类:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81Set%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%85%B6%E4%B8%BB%E8%A6%81%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="toc-number">11.3.</span> <span class="toc-text">3、Set接口及其主要实现类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81Map%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%85%B6%E4%B8%BB%E8%A6%81%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="toc-number">11.4.</span> <span class="toc-text">4、Map接口及其主要实现类:</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0-%E6%B3%9B%E5%9E%8B"><span class="toc-number">12.</span> <span class="toc-text">第十三章: 泛型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AB%A0%EF%BC%9AFile%E7%B1%BB%E4%B8%8EIO%E6%B5%81"><span class="toc-number">13.</span> <span class="toc-text">第十五章：File类与IO流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%B8%83%E7%AB%A0%EF%BC%9A%E5%8F%8D%E5%B0%84"><span class="toc-number">14.</span> <span class="toc-text">第十七章：反射</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E8%A7%A3%E7%AD%94"><span class="toc-number">14.1.</span> <span class="toc-text">常见面试题解答:</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/11/springboot%E7%AC%94%E8%AE%B0%E5%B0%8F%E7%BB%93/" title="springboot笔记小结">springboot笔记小结</a><time datetime="2025-03-11T11:20:40.000Z" title="发表于 2025-03-11 19:20:40">2025-03-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/11/%E7%8B%82%E7%A5%9Espring5/" title="狂神spring5">狂神spring5</a><time datetime="2025-03-11T11:14:04.000Z" title="发表于 2025-03-11 19:14:04">2025-03-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/11/Spring%E7%AC%94%E8%AE%B0/" title="Spring笔记">Spring笔记</a><time datetime="2025-03-11T11:12:33.000Z" title="发表于 2025-03-11 19:12:33">2025-03-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/11/Mybatis%E9%BB%91%E9%A9%AC%E7%AC%94%E8%AE%B0/" title="Mybatis黑马笔记">Mybatis黑马笔记</a><time datetime="2025-03-11T11:06:54.000Z" title="发表于 2025-03-11 19:06:54">2025-03-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/11/Redis%E5%B0%8F%E7%BB%93/" title="Redis小结">Redis小结</a><time datetime="2025-03-11T11:00:26.000Z" title="发表于 2025-03-11 19:00:26">2025-03-11</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By John Doe</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.3.5"></script><script src="/js/main.js?v=5.3.5"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (false) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.4.1/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>