<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>狂神spring5 | 他乡遇故知</title><meta name="author" content="John Doe"><meta name="copyright" content="John Doe"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="目录标题 Spring1.1 简介1.2 优点1.3 组成1.4 拓展 IOC理论推导 HelloSpring IOC创建对象的方式 Spring配置5.1 取别名5.2 Bean的配置5.3 import 依赖注入6.1 构造器注入6.2 Set方式注入【重点】6.3 拓展方式注入6.4 Bean作用域 Bean的自动装配7.1 测试7.2 ByName自动装配7.3 ByType自动装配7.4">
<meta property="og:type" content="article">
<meta property="og:title" content="狂神spring5">
<meta property="og:url" content="https://xz613.github.io/2025/03/11/%E7%8B%82%E7%A5%9Espring5/index.html">
<meta property="og:site_name" content="他乡遇故知">
<meta property="og:description" content="目录标题 Spring1.1 简介1.2 优点1.3 组成1.4 拓展 IOC理论推导 HelloSpring IOC创建对象的方式 Spring配置5.1 取别名5.2 Bean的配置5.3 import 依赖注入6.1 构造器注入6.2 Set方式注入【重点】6.3 拓展方式注入6.4 Bean作用域 Bean的自动装配7.1 测试7.2 ByName自动装配7.3 ByType自动装配7.4">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://xz613.github.io/img/avator.png">
<meta property="article:published_time" content="2025-03-11T11:14:04.000Z">
<meta property="article:modified_time" content="2025-03-11T11:18:40.505Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://xz613.github.io/img/avator.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "狂神spring5",
  "url": "https://xz613.github.io/2025/03/11/%E7%8B%82%E7%A5%9Espring5/",
  "image": "https://xz613.github.io/img/avator.png",
  "datePublished": "2025-03-11T11:14:04.000Z",
  "dateModified": "2025-03-11T11:18:40.505Z",
  "author": [
    {
      "@type": "Person",
      "name": "John Doe",
      "url": "https://xz613.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://xz613.github.io/2025/03/11/%E7%8B%82%E7%A5%9Espring5/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.3.5"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.7.2/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '狂神spring5',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background: [object Object];"></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background: [object Object];"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/img/avator.png" alt="Logo"><span class="site-name">他乡遇故知</span></a><a class="nav-page-title" href="/"><span class="site-name">狂神spring5</span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">狂神spring5</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-03-11T11:14:04.000Z" title="发表于 2025-03-11 19:14:04">2025-03-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-03-11T11:18:40.505Z" title="更新于 2025-03-11 19:18:40">2025-03-11</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">11.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>51分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h3 id="目录标题"><a href="#目录标题" class="headerlink" title="目录标题"></a>目录标题</h3><ol>
<li>Spring<br>1.1 简介<br>1.2 优点<br>1.3 组成<br>1.4 拓展</li>
<li>IOC理论推导</li>
<li>HelloSpring</li>
<li>IOC创建对象的方式</li>
<li>Spring配置<br>5.1 取别名<br>5.2 Bean的配置<br>5.3 import</li>
<li>依赖注入<br>6.1 构造器注入<br>6.2 Set方式注入【重点】<br>6.3 拓展方式注入<br>6.4 Bean作用域</li>
<li>Bean的自动装配<br>7.1 测试<br>7.2 ByName自动装配<br>7.3 ByType自动装配<br>7.4 使用注解实现自动装配</li>
<li>使用注解开发</li>
<li>用JAVA的方式配置Spring</li>
<li>代理模式<br>10.1 静态代理<br>10.2 加深理解<br>10.3 动态代理</li>
<li>AOP<br>11.1 什么是AOP<br>11.2 AOP在Spring中的作用<br>11.3 使用Spring实现AOP</li>
<li>整合Mybatis<br>12.1 回忆Mybatis<br>12.2 Mybatis-Spring</li>
<li>声明式事务<br>13.1 回顾事务<br>13.2 Spring中的事务管理</li>
<li>总结</li>
</ol>
<h2 id="1-Spring"><a href="#1-Spring" class="headerlink" title="1.Spring"></a>1.Spring</h2><h3 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a><strong>1.1 简介</strong></h3><p>SSH：Struct2+Spring+Hibernate<br>SSM：SpringMVC+Spring+Mybatis<br>官网：<a target="_blank" rel="noopener" href="https://spring.io/projects/spring-framework#overview">https://spring.io/projects/spring-framework#overview</a><br>官方下载地址：<a target="_blank" rel="noopener" href="https://repo.spring.io/release/org/springframework/spring/">https://repo.spring.io/release/org/springframework/spring/</a><br>GitHub：<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-framework">https://github.com/spring-projects/spring-framework</a></p>
<pre><code class="highlight plaintext">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
    &lt;version&gt;5.2.0.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;
    &lt;version&gt;5.2.0.RELEASE&lt;/version&gt;
&lt;/dependency&gt;</code></pre>

<h3 id="1-2-优点"><a href="#1-2-优点" class="headerlink" title="1.2 优点"></a>1.2 优点</h3><ul>
<li>Spring是一个开源的免费的框架（容器）。</li>
<li>Spring是一个轻量级、非侵入式的框架。</li>
<li>控制反转（IOC）、面向切面编程（AOP)。</li>
<li>支持事务的处理，对框架整合的支持。</li>
</ul>
<p><strong>总结：Spring是一个轻量级的控制反转（IOC）和面向切面编程（AOP）的框架。</strong></p>
<h3 id="1-3-组成"><a href="#1-3-组成" class="headerlink" title="1.3 组成"></a>1.3 组成</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/d45b676acb3840fe4c62e82e6e5901c4.png" alt="在这里插入图片描述"></p>
<h3 id="1-4-拓展"><a href="#1-4-拓展" class="headerlink" title="1.4 拓展"></a>1.4 拓展</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/d52256d9af48158ba33e5ec7b04895ea.png" alt="在这里插入图片描述"><br><strong>Spring Boot：</strong></p>
<ul>
<li>一个快速开发的脚手架。</li>
<li>基于SpringBoot可以快速的开发单个微服务。</li>
<li>约定大于配置。</li>
</ul>
<p><strong>Spring Cloud：</strong></p>
<ul>
<li>SpringCloud是基于SpringBoot实现。</li>
</ul>
<h2 id="2-IOC理论推导"><a href="#2-IOC理论推导" class="headerlink" title="2. IOC理论推导"></a>2. IOC理论推导</h2><p>在之前的业务中，用户的需求可能会影响原来的代码，需要根据需求修改相应的代码。如果程序代码量很大，修改的成本十分昂贵。</p>
<p><strong>可使用set接口实现：</strong></p>
<pre><code class="highlight plaintext">public class UserServiceImpl implements UserService&#123;

    private UserDao userDao ;

    //利用set进行动态实现值的注入
    public void setUserDao(UserDao userDao) &#123;
        this.userDao = userDao;
    &#125;

    public void getUser()&#123;
        userDao.getUser();
    &#125;
&#125;</code></pre>

<ul>
<li>之前，程序是主动创建对象，控制权在程序员的手上。</li>
<li>使用了set注入后，程序不再具有主动性，变成了被动的接受对象。</li>
</ul>
<pre><code class="highlight plaintext">public class MyTest &#123;
    public static void main(String[] args) &#123;
        //用户实际调用的是业务层，dao层他们不需要接触。
        UserService userService = new UserServiceImpl();
        
        System.out.println($END$);
		//((UserServiceImpl) userService).setUserDao(new UserDaoImpl());

        userService.getUser();
    &#125;
&#125;</code></pre>

<p><img src="https://i-blog.csdnimg.cn/blog_migrate/aee73111fd5a9699ca5484ea71aa1a83.png" alt="在这里插入图片描述"><br><strong>IOC本质：</strong></p>
<p><strong>控制反转IoC（Inversion of Control）</strong>，是一种设计思想，DI（依赖注入）是实现IoC的一种方法，也有人认为DI只是IoC的另一种说法。没有IoC的程序中，我们使用面向对象编程，对象的创建与对象间的依赖关系完全硬编码在程序中，对象的创建由程序自己控制，控制反转后将对象的创建转移给第三方，个人认为所谓控制反转就是：获得依赖对象的方式反转了。</p>
<p>采用XML方式配置Bean的时候，Bean的定义信息是和实现分离的，而采用注解的方式可以把两者合为一体，Bean的定义信息直接以注解的形式定义在实现类中，从而达到了零配置的目的。</p>
<p><strong>控制反转是一种通过描述（XML或注解）并通过第三方去生产或获取特定对象的方式。在Spring中实现控制反转的是IoC容器，其实现方法是依赖注入（Dependency Injection，DI）。</strong></p>
<h2 id="3-HelloSpring"><a href="#3-HelloSpring" class="headerlink" title="3.HelloSpring"></a>3.HelloSpring</h2><p>1、新建一个maven项目，编写实体类</p>
<pre><code class="highlight plaintext">public class Hello &#123;
    private String str;

    public String getStr() &#123;
        return str;
    &#125;

    public void setStr(String str) &#123;
        this.str = str;
    &#125;

    @Override
    public String toString() &#123;
        return &quot;Hello&#123;&quot; +
                &quot;str=&#x27;&quot; + str + &#x27;\&#x27;&#x27; +
                &#x27;&#125;&#x27;;
    &#125;
&#125;</code></pre>

<p>2、编写bean.xml配置文件</p>
<pre><code class="highlight plaintext">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;


    &lt;!--使用Spring来创建对象，在Spring这些都称为Bean
    类型 变量名 = new 类型();
    Hello hello = new Hello();

    id = 变量名
    class = new的对象
    property 相当于给对象中的属性设置一个值！
        --&gt;
    &lt;bean id=&quot;hello&quot; class=&quot;com.kuang.pojo.Hello&quot;&gt;
        &lt;property name=&quot;str&quot; value=&quot;Spring&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;</code></pre>

<p>3、测试</p>
<pre><code class="highlight plaintext">public class MyTest &#123;
    public static void main(String[] args) &#123;
        //获取Spring的上下文对象
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);
        //我们的对象现在都在Spring中的管理了，我们需要使用，直接去里面取出来就可以！
        Hello hello = (Hello) context.getBean(&quot;hello&quot;);
        System.out.println(hello.toString());
    &#125;
&#125;</code></pre>

<p>思考问题：</p>
<ul>
<li>Hello对象是谁创建的？</li>
</ul>
<p>Hello对象是由Spring创建的。</p>
<ul>
<li>Hello对象的属性是怎么设置的？</li>
</ul>
<p>Hello对象的属性是由Spring容器设置的。</p>
<p><strong>控制：</strong> 谁来控制对象的创建，传统应用程序的对象是由程序本身控制创建的，使用Spring后，对象是由Spring来创建的。</p>
<p><strong>反转：</strong> 程序本身不创建对象，而变成被动的接收对象。</p>
<p><strong>依赖注入：</strong> 就是利用set方法来进行注入的。</p>
<p><strong>IOC是一种编程思想，由主动的编程变成被动的接收。</strong></p>
<p>到了现在，我们彻底不用在程序中去改动了，要实现不同的操作，只需要在xml配置文件中进行修改，所谓的IOC，一句话搞定：对象由Spring来创建，管理，装配！</p>
<h2 id="4-IOC创建对象的方式"><a href="#4-IOC创建对象的方式" class="headerlink" title="4. IOC创建对象的方式"></a>4. IOC创建对象的方式</h2><p>1、使用无参构造创建对象，默认。</p>
<pre><code class="highlight plaintext">&lt;bean id=&quot;user&quot; class=&quot;com.kuang.pojo.User&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;houmou&quot;/&gt;
&lt;/bean&gt;</code></pre>

<p>2、假设要使用有参构造创建对象。</p>
<p>方式一：下标赋值</p>
<pre><code class="highlight plaintext">&lt;!--第一种方式：下标赋值    --&gt;
&lt;bean id=&quot;user&quot; class=&quot;com.kuang.pojo.User&quot;&gt;
    &lt;constructor-arg index=&quot;0&quot; value=&quot;狂神说Java&quot;/&gt;
&lt;/bean&gt;</code></pre>

<p>方式二：类型</p>
<pre><code class="highlight plaintext">&lt;!--第二种方式：通过类型的创建，不建议使用    --&gt;
&lt;bean id=&quot;user&quot; class=&quot;com.kuang.pojo.User&quot;&gt;
    &lt;constructor-arg type=&quot;java.lang.String&quot; value=&quot;lifa&quot;/&gt;
&lt;/bean&gt;</code></pre>

<p>方式三：参数名</p>
<pre><code class="highlight plaintext">&lt;bean id=&quot;user&quot; class=&quot;com.kuang.pojo.User&quot;&gt;
     &lt;constructor-arg name=&quot;name&quot; value=&quot;wangfang&quot;/&gt;
&lt;/bean&gt;</code></pre>

<p><strong>总结：在配置文件加载的时候，容器中管理的对象就已经初始化了！</strong></p>
<h2 id="5-Spring配置"><a href="#5-Spring配置" class="headerlink" title="5. Spring配置"></a>5. <a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=Spring%E9%85%8D%E7%BD%AE&spm=1001.2101.3001.7020">Spring配置</a></h2><h3 id="5-1-取别名"><a href="#5-1-取别名" class="headerlink" title="5.1 取别名"></a>5.1 取别名</h3><pre><code class="highlight plaintext">&lt;!--别名，如果添加了别名，我们也可以使用别名获取到这个对象--&gt;
&lt;alias name=&quot;user&quot; alias=&quot;userNew&quot;/&gt;</code></pre>

<h3 id="5-2-Bean的配置"><a href="#5-2-Bean的配置" class="headerlink" title="5.2 Bean的配置"></a>5.2 Bean的配置</h3><pre><code>&lt;!--
id：bean的唯一标识符，也就是相当于我们学的对象名
class：bean对象所对应的全限定名：包名+类名
name：也是别名，而且name可以同时取多个别名
    --&gt;
&lt;bean id=&quot;userT&quot; class=&quot;com.kuang.pojo.UserT&quot; name=&quot;user2 u2,u3;u4&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;狂神&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<p>5.3 import<br>这个import。一般用于团队开发使用，它可以将多个配置文件，导入合并为一个。<br>假设，现在项目中有多个人开发，这三个人负责不同的类开发，不同的类需要注册在不同的bean中，我们可以利用import将所有人的beans.xml合并为一个总的！</p>
<p><strong>applicationContext.xml</strong></p>
<pre><code class="highlight xml"><span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">&quot;bean.xml&quot;</span>/&gt;</span>
<span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">&quot;bean2.xml&quot;</span>/&gt;</span>
<span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">&quot;bean3.xml&quot;</span>/&gt;</span></code></pre>

<p>使用的时候，直接使用总的配置就可以了。</p>
<h2 id="6-依赖注入"><a href="#6-依赖注入" class="headerlink" title="6. 依赖注入"></a>6. 依赖注入</h2><p>依赖注入简单来说就是给类中的属性赋值。</p>
<h3 id="6-1-构造器注入"><a href="#6-1-构造器注入" class="headerlink" title="6.1 构造器注入"></a>6.1 构造器注入</h3><p><strong>前面已经介绍过，参考4、IOC创建对象的方式</strong></p>
<h3 id="6-2-Set方式注入【重点】"><a href="#6-2-Set方式注入【重点】" class="headerlink" title="6.2 Set方式注入【重点】"></a>6.2 Set方式注入【重点】</h3><p><strong>依赖注入：Set注入</strong></p>
<ul>
<li>依赖：bean对象的创建依赖于容器。</li>
<li>注入：bean对象中的所有属性，由容器来注入。</li>
</ul>
<p>【环境搭建】</p>
<p>1、编写实体类</p>
<pre><code class="highlight plaintext">package com.kuang.pojo;

public class Address &#123;
    private String address;

    public String getAddress() &#123;
        return address;
    &#125;

    public void setAddress(String address) &#123;
        this.address = address;
    &#125;

    @Override
    public String toString() &#123;
        return &quot;Address&#123;&quot; +
                &quot;address=&#x27;&quot; + address + &#x27;\&#x27;&#x27; +
                &#x27;&#125;&#x27;;
    &#125;
&#125;</code></pre>

<pre><code class="highlight plaintext">package com.kuang.pojo;

import java.util.*;

@Date
public class Student &#123;

    private String name;
    private Address address;
    private String[] books;
    private List&lt;String&gt; hobbys;
    private Map&lt;String,String&gt; card;
    private Set&lt;String&gt; games;
    private Properties info;
    private String wife;
    
&#125;</code></pre>

<p>2、配置beans.xml文件</p>
<pre><code class="highlight plaintext">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:jdbc=&quot;http://www.springframework.org/schema/jdbc&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/jdbc http://www.springframework.org/schema/jdbc/spring-jdbc.xsd&quot;&gt;

    &lt;bean id=&quot;address&quot; class=&quot;com.kuang.pojo.Address&quot;&gt;
        &lt;property name=&quot;address&quot; value=&quot;河南&quot;/&gt;
    &lt;/bean&gt;
    
    &lt;bean id=&quot;student&quot; class=&quot;com.kuang.pojo.Student&quot;&gt;
        &lt;!--    第一种注入：普通值注入，value--&gt;
        &lt;property name=&quot;name&quot; value=&quot;houshuaixin&quot;/&gt;

        &lt;!--    第二种注入：bean注入，ref--&gt;
        &lt;property name=&quot;address&quot; ref=&quot;address&quot;/&gt;

        &lt;!--    第三种注入：数组的注入--&gt;
        &lt;property name=&quot;books&quot;&gt;
            &lt;array&gt;
                &lt;value&gt;红楼梦&lt;/value&gt;
                &lt;value&gt;西游记&lt;/value&gt;
                &lt;value&gt;水浒传&lt;/value&gt;
                &lt;value&gt;三国演义&lt;/value&gt;
            &lt;/array&gt;
        &lt;/property&gt;

        &lt;!--    list注入--&gt;
        &lt;property name=&quot;hobbys&quot;&gt;
            &lt;list&gt;
                &lt;value&gt;听歌&lt;/value&gt;
                &lt;value&gt;敲代码&lt;/value&gt;
                &lt;value&gt;看电影&lt;/value&gt;
            &lt;/list&gt;
        &lt;/property&gt;

        &lt;!--    Map注入--&gt;
        &lt;property name=&quot;card&quot;&gt;
            &lt;map&gt;
                &lt;entry key=&quot;身份证&quot; value=&quot;1111111&quot;/&gt;
                &lt;entry key=&quot;银行卡&quot; value=&quot;2222222&quot;/&gt;
            &lt;/map&gt;
        &lt;/property&gt;


        &lt;!--    Set注入--&gt;
        &lt;property name=&quot;games&quot;&gt;
            &lt;set&gt;
                &lt;value&gt;CF&lt;/value&gt;
                &lt;value&gt;LOL&lt;/value&gt;
                &lt;value&gt;BOB&lt;/value&gt;
            &lt;/set&gt;
        &lt;/property&gt;

        &lt;!--    null注入--&gt;
        &lt;property name=&quot;wife&quot;&gt;
            &lt;null&gt;&lt;/null&gt;
        &lt;/property&gt;

        &lt;!--    Properties注入--&gt;
        &lt;property name=&quot;info&quot;&gt;
            &lt;props&gt;
                &lt;prop key=&quot;学号&quot;&gt;215151&lt;/prop&gt;
                &lt;prop key=&quot;性别&quot;&gt;男&lt;/prop&gt;
            &lt;/props&gt;
        &lt;/property&gt;

    &lt;/bean&gt;
    
&lt;/beans&gt;</code></pre>

<p>3、测试</p>
<pre><code class="highlight plaintext">public static void main(String[] args) &#123;
    ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);
    Student student = (Student)context.getBean(&quot;student&quot;);
    System.out.println(student.toString());
&#125;</code></pre>

<h3 id="6-3-拓展方式注入"><a href="#6-3-拓展方式注入" class="headerlink" title="6.3 拓展方式注入"></a>6.3 拓展方式注入</h3><p>可以使用p命名空间和c命名空间进行注入，但需要导入xml约束：</p>
<pre><code>   xmlns:p=&quot;http://www.springframework.org/schema/p&quot;
   xmlns:c=&quot;http://www.springframework.org/schema/c&quot;
</code></pre>
<p>beans.xml配置文件：</p>
<pre><code class="highlight plaintext">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:jdbc=&quot;http://www.springframework.org/schema/jdbc&quot;
       xmlns:p=&quot;http://www.springframework.org/schema/p&quot;
       xmlns:c=&quot;http://www.springframework.org/schema/c&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/jdbc http://www.springframework.org/schema/jdbc/spring-jdbc.xsd&quot;&gt;

    &lt;!--P命名空间注入，可以直接注入属性的值:property--&gt;
    &lt;bean id=&quot;user&quot; class=&quot;com.kuang.pojo.User&quot; p:name=&quot;狂神&quot; p:age=&quot;32&quot;/&gt;

    &lt;!--C命名空间注入，通过构造器注入:construct-args--&gt;
    &lt;bean id=&quot;user2&quot; class=&quot;com.kuang.pojo.User&quot; c:age=&quot;18&quot; c:name=&quot;狂神&quot;/&gt;
    
&lt;/beans&gt;</code></pre>

<p>测试：</p>
<pre><code class="highlight plaintext">@Test
public void test1()&#123;
    ApplicationContext context = new ClassPathXmlApplicationContext(&quot;userbeans.xml&quot;);
    User user = context.getBean(&quot;user2&quot;, User.class); //此方式不用再强转
    System.out.println(user);
&#125;</code></pre>

<h3 id="6-4-Bean作用域"><a href="#6-4-Bean作用域" class="headerlink" title="6.4 Bean作用域"></a>6.4 Bean作用域</h3><p>1、单例模式（Spring默认机制）</p>
<pre><code class="highlight plaintext">&lt;bean id=&quot;user2&quot; class=&quot;com.kuang.pojo.User&quot; c:age=&quot;18&quot; c:name=&quot;狂神&quot; 
scope=&quot;singleton&quot;/&gt;</code></pre>

<pre><code class="highlight plaintext">ApplicationContext context = new ClassPathXmlApplicationContext(&quot;userbeans.xml&quot;);
User user1 = context.getBean(&quot;user2&quot;, User.class);
User user2 = context.getBean(&quot;user2&quot;, User.class);
System.out.println(user1 == user2); //ture</code></pre>

<p>2、原型模式：每次从容器中get的时候，都会产生一个新的对象。</p>
<pre><code class="highlight xml"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.User&quot;</span> <span class="attr">c:age</span>=<span class="string">&quot;18&quot;</span> <span class="attr">c:name</span>=<span class="string">&quot;狂神&quot;</span> </span>
<span class="tag"><span class="attr">scope</span>=<span class="string">&quot;prototype&quot;</span>/&gt;</span></code></pre>

<pre><code class="highlight plaintext">ApplicationContext context = new ClassPathXmlApplicationContext(&quot;userbeans.xml&quot;);
User user1 = context.getBean(&quot;user2&quot;, User.class);
User user2 = context.getBean(&quot;user2&quot;, User.class);
System.out.println(user1 == user2); //false</code></pre>

<p>3、其余的request、session、application，这些只能在web开发中使用到。</p>
<h2 id="7-Bean的自动装配"><a href="#7-Bean的自动装配" class="headerlink" title="7. Bean的自动装配"></a>7. Bean的<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D&spm=1001.2101.3001.7020">自动装配</a></h2><ul>
<li>自动装配是Spring满足Bean依赖的一种方式。</li>
<li>Spring会在上下文中自动寻找，并自动给bean装配属性。</li>
</ul>
<p>在Spring中有三种装配的方式：</p>
<ol>
<li>在xml中显式的配置。</li>
<li>在java中显示配置。</li>
</ol>
<p><strong>3. 隐式的自动装配bean【重要】。</strong></p>
<h3 id="7-1-测试"><a href="#7-1-测试" class="headerlink" title="7.1 测试"></a>7.1 测试</h3><p>环境搭建：一个人有两个宠物。</p>
<pre><code class="highlight plaintext">public class Cat &#123;
    public void shout()&#123;
        System.out.println(&quot;猫叫&quot;);
    &#125;
&#125;</code></pre>

<pre><code class="highlight plaintext">public class Dog &#123;
    public void shout()&#123;
        System.out.println(&quot;狗叫&quot;);
    &#125;
&#125;</code></pre>

<pre><code class="highlight plaintext">public class People &#123;
    private Cat cat;
    private Dog dog;
    private String name;
&#125;</code></pre>

<pre><code class="highlight plaintext">    &lt;bean id=&quot;cat&quot; class=&quot;com.kuang.pojo.Cat&quot;/&gt;
    &lt;bean id=&quot;dog&quot; class=&quot;com.kuang.pojo.Dog&quot;/&gt;

&lt;bean id=&quot;people&quot; class=&quot;com.kuang.pojo.People&quot; &gt;
    &lt;property name=&quot;name&quot; value=&quot;狂神&quot;/&gt;
    &lt;property name=&quot;cat&quot; ref=&quot;cat&quot;/&gt;
    &lt;property name=&quot;dog&quot; ref=&quot;dog&quot;/&gt;
&lt;/bean&gt;</code></pre>

<h3 id="7-2-ByName自动装配"><a href="#7-2-ByName自动装配" class="headerlink" title="7.2 ByName自动装配"></a>7.2 ByName自动装配</h3><p>byName:会自动在容器上下文中查找，和自己对象set方法后面的值对应的beanid。</p>
<pre><code class="highlight plaintext">&lt;!--   byName:会自动在容器上下文中查找，和自己对象set方法后面的值对应的beanid --&gt;
        &lt;bean id=&quot;people&quot; class=&quot;com.kuang.pojo.People&quot; autowire=&quot;byName&quot;&gt;
            &lt;property name=&quot;name&quot; value=&quot;狂神&quot;/&gt;
&lt;!--            &lt;property name=&quot;cat&quot; ref=&quot;cat&quot;/&gt;--&gt;
&lt;!--            &lt;property name=&quot;dog&quot; ref=&quot;dog&quot;/&gt;--&gt;
        &lt;/bean&gt;</code></pre>

<h3 id="7-3-ByType自动装配"><a href="#7-3-ByType自动装配" class="headerlink" title="7.3 ByType自动装配"></a>7.3 ByType自动装配</h3><p>byType:会自动在容器上下文中查找，和自己对象属性类型相同的bean，需要保证属性类型全局唯一 。</p>
<pre><code class="highlight plaintext">        &lt;bean id=&quot;cat&quot; class=&quot;com.kuang.pojo.Cat&quot;/&gt;
        &lt;bean id=&quot;dog&quot; class=&quot;com.kuang.pojo.Dog&quot;/&gt;  
&lt;!--   byType:会自动在容器上下文中查找，和自己对象属性类型相同的bean，需要保证属性类型全局唯一 --&gt;
        &lt;bean id=&quot;people&quot; class=&quot;com.kuang.pojo.People&quot; autowire=&quot;byType&quot;&gt;
            &lt;property name=&quot;name&quot; value=&quot;狂神&quot;/&gt;
&lt;!--            &lt;property name=&quot;cat&quot; ref=&quot;cat&quot;/&gt;--&gt;
&lt;!--            &lt;property name=&quot;dog&quot; ref=&quot;dog&quot;/&gt;--&gt;
        &lt;/bean&gt;
</code></pre>

<p><strong>小结：</strong></p>
<ul>
<li>ByName的时候，需要保证所有的bean的id唯一，并且这个bean需要和自动注入的属性的set方法的值一致。</li>
<li>ByType的时候，需要保证所有的bean的class唯一，并且这个bean需要和自动注入的属性类型一致。</li>
</ul>
<h3 id="7-4-使用注解实现自动装配"><a href="#7-4-使用注解实现自动装配" class="headerlink" title="7.4 使用注解实现自动装配"></a>7.4 使用注解实现自动装配</h3><p>要使用注解须知：</p>
<ol>
<li>导入约束： context约束。</li>
<li>配置注解的支持：</li>
</ol>
<pre><code class="highlight plaintext">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
	        https://www.springframework.org/schema/beans/spring-beans.xsd
	        http://www.springframework.org/schema/context
	        https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;
		
		&lt;!--开启注解的支持    --&gt;
        &lt;context:annotation-config/&gt;
&lt;/beans&gt;</code></pre>

<p><strong>@Autowired</strong></p>
<p>直接在属性上使用即可，也可以在set方法上使用。</p>
<pre><code>@Autowired
private Cat cat;
@Autowired
private Dog dog;
</code></pre>
<p>使用Autowired，可以不用再编写set方法，前提是自动装配的属性再IOC容器中存在，且符合名字byname。</p>
<p><strong>科普：</strong></p>
<p><strong>@Nullable</strong> 字段标记了这个注解，表明该字段可以为null</p>
<pre><code class="highlight plaintext">public People(@Nullable String name) &#123;
   this.name = name;
&#125;</code></pre>

<pre><code class="highlight plaintext">public @interface Autowired &#123;
    boolean required() default true;
&#125;</code></pre>

<p>测试代码</p>
<pre><code class="highlight plaintext">//    如果显式的定义了AutoWired的required属性为false，说明该对象可以为null，否则不能为空。
    @Autowired(required = false)
    private Cat cat;
    @Autowired
    private Dog dog;
    private String name;</code></pre>

<p>如果@Autowired自动装配的环境比较复杂，自动装配无法通过@Autowired完成时，可以使用@Qualifier（value&#x3D;”***“）去配置@Autowired的使用，指定一个唯一的bean对象注入。</p>
<pre><code class="highlight plaintext">&lt;bean id=&quot;cat&quot; class=&quot;com.kuang.pojo.Cat&quot;/&gt;
&lt;bean id=&quot;cat222&quot; class=&quot;com.kuang.pojo.Cat&quot;/&gt;
&lt;bean id=&quot;cat333&quot; class=&quot;com.kuang.pojo.Cat&quot;/&gt;</code></pre>

<pre><code class="highlight plaintext">@Autowired
@Qualifier(value = &quot;cat222&quot;)
private Cat cat;</code></pre>

<p><strong>@Resource注解</strong></p>
<pre><code class="highlight xml"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dog111&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.Dog&quot;</span>/&gt;</span>
<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dog222&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.Dog&quot;</span>/&gt;</span></code></pre>

<pre><code class="highlight plaintext">@Resource(name = &quot;dog222&quot;)
private Dog dog;
private String name;</code></pre>

<p>小结：</p>
<p>@Resource和@Autowired的区别：</p>
<p>都是用来自动装配的，都可以放在属性字段上。<br>@Autowired通过byType的方式实现，而且必须要求这个对象存在。【常用】<br>@Resource默认通过byName的方式实现，如果找不到名字，则通过byType实现，两种都找不到，报错。<br>执行顺序：@Autowired通过byType的方式实现。@Resource使用byName的方式实现。</p>
<h2 id="8-使用注解开发"><a href="#8-使用注解开发" class="headerlink" title="8. 使用注解开发"></a>8. 使用注解开发</h2><p>在Spring4之后，要使用注解开发，需要导入aop的包<br><img src="https://i-blog.csdnimg.cn/blog_migrate/371b1115d4abc46f7f35a1ff20b4597c.png" alt="在这里插入图片描述"><br>使用注解开发需要导入context约束，增加注解的支持。</p>
<pre><code class="highlight plaintext">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
	        https://www.springframework.org/schema/beans/spring-beans.xsd
	        http://www.springframework.org/schema/context
	        https://www.springframework.org/schema/context/spring-context.xsd
            http://www.springframework.org/schema/aop
            https://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;

    &lt;!--指定要扫描的包，这个包下的注解就会生效--&gt;
    &lt;context:component-scan base-package=&quot;com.kuang.pojo&quot;/&gt;

    &lt;!--开启注解的支持    --&gt;
    &lt;context:annotation-config/&gt;
    
&lt;/beans&gt;</code></pre>

<p><strong>1、bean</strong></p>
<p><strong>2、属性如何注入：@Component组件</strong></p>
<pre><code class="highlight plaintext">//等价于&lt;bean id=&quot;user&quot; class=&quot;com.kuang.pojo.User&quot;/&gt;
//@Component组件
@Component
public class User &#123;
    //相当于&lt;property name=&quot;name&quot; value=&quot;kuangshen&quot;/&gt;
    @Value(&quot;kuangshen&quot;)
    public String name ;

    @Value(&quot;kuangshen&quot;)
    public void setName(String name) &#123;
        this.name = name;
    &#125;
&#125;</code></pre>

<p><strong>3、衍生的注解</strong><br>@Component有几个衍生的注解，在web开发中，会按照mvc三层架构分层。<br>dao层 【@Repository】<br>service层 【@Service】<br>controller层 【@Controller】<br>这四个注解的功能相同，都是代表将某个类注册到Spring中，装配Bean。</p>
<p><strong>4、自动装配</strong><br>@Autowired – @Qualifier<br>@Nullable<br>@Resource</p>
<p><strong>5. 作用域</strong></p>
<pre><code class="highlight java"><span class="meta">@Scope(&quot;prototype&quot;)</span> <span class="comment">//原型模式</span>
<span class="meta">@Scope(&quot;singleton&quot;)</span> <span class="comment">//单例模式</span>
<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span>&#123;
&#125;</code></pre>

<p><strong>6、小结</strong></p>
<p><strong>xml与注解</strong></p>
<ul>
<li><p>xml更加万能，适用于任何场合，维护简单。</p>
</li>
<li><p>注解不是自己类使用不了，维护相对复杂。</p>
</li>
</ul>
<p><strong>xml与注解最佳实践：</strong></p>
<ul>
<li>xml用来管理bean。</li>
<li>注解只负责完成属性的注入。</li>
<li>在使用过程中，只需要注意：必须要让注解生效，需开启注解的支持。</li>
</ul>
<pre><code class="highlight plaintext">&lt;!--指定要扫描的包，这个包下的注解就会生效--&gt;
&lt;context:component-scan base-package=&quot;com.kuang&quot;/&gt;
&lt;!--开启注解的支持    --&gt;
&lt;context:annotation-config/&gt;</code></pre>

<h2 id="9-用JAVA的方式配置Spring"><a href="#9-用JAVA的方式配置Spring" class="headerlink" title="9. 用JAVA的方式配置Spring"></a>9. 用JAVA的方式配置Spring</h2><p>完全不使用Spring的xml配置，交给Java来做。<br>JavaConfig是Spring的一个子项目，在Spring4之后，成为一个核心功能。</p>
<p><strong>实体类</strong></p>
<pre><code class="highlight plaintext">package com.kuang.pojo;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

@Component
public class User &#123;
    public String name;

    public String getName() &#123;
        return name;
    &#125;

    @Value(&quot;qinjiang&quot;)
    public void setName(String name) &#123;
        this.name = name;
    &#125;

    @Override
    public String toString() &#123;
        return &quot;User&#123;&quot; +
                &quot;name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +
                &#x27;&#125;&#x27;;
    &#125;
&#125;</code></pre>

<p><strong>配置文件</strong></p>
<pre><code class="highlight plaintext">package com.kuang.config;

import com.kuang.pojo.User;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Import;

//@Configuration也会被Spring容器托管，注册到容器中，其本身就是@Component。
//@Configuration代表一个配置类，和之前的beans.xml相同。
@Configuration
@ComponentScan(&quot;com.kuang.pojo&quot;) //扫描包
@Import(MyConfig2.class)
public class MyConfig &#123;
    //注册一个bean，就相当于之前写的bean标签。
    //方法的名字，相当于bean标签的id属性。
    //方法的返回值，相当于bean标签的class属性。
    @Bean
    public User getUser()&#123;
        return new User(); //返回要注入bean的对象
    &#125;
&#125;</code></pre>

<p><strong>测试类</strong></p>
<pre><code class="highlight plaintext">import com.kuang.config.MyConfig;
import com.kuang.pojo.User;
import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;

public class MyTest &#123;
    public static void main(String[] args) &#123;
        //如果完全使用了配置类的方式做，仅能通过AnnotationConfig上下文来获取容器，通过配置类的class对象加载。
        ApplicationContext context = new AnnotationConfigApplicationContext(MyConfig.class);
        User user = (User) context.getBean(&quot;getUser&quot;);
        System.out.println(user.getName());
    &#125;
&#125;</code></pre>

<p>这种纯Java 的配置，在SpringBoot中随处可见。</p>
<h2 id="10-代理模式"><a href="#10-代理模式" class="headerlink" title="10. 代理模式"></a>10. 代理模式</h2><p>SpringAoP的底层为代理模式。</p>
<p>代理模式分类：</p>
<ul>
<li>静态代理</li>
<li>动态代理<br><img src="https://i-blog.csdnimg.cn/blog_migrate/42be9242b135753adf6419addc8d2cc0.png" alt="在这里插入图片描述"></li>
</ul>
<h3 id="10-1-静态代理"><a href="#10-1-静态代理" class="headerlink" title="10.1 静态代理"></a>10.1 静态代理</h3><p><strong>角色分析：</strong></p>
<ul>
<li>抽象角色：一般会使用接口或者抽象类解决。</li>
<li>真实角色：被代理的角色。</li>
<li>代理角色：代理真实角色，一般会做一些附属操作。</li>
<li>客户：访问代理对象的人。</li>
</ul>
<p><strong>要求：真实角色和代理角色都要实现同一个接口。</strong></p>
<p>代码步骤：</p>
<p>1、接口</p>
<pre><code class="highlight plaintext">//租房
public interface Rent &#123;
    public void rent();
&#125;</code></pre>

<p>2、真实角色</p>
<pre><code class="highlight plaintext">//房东
public class Host implements Rent&#123;
    @Override
    public void rent() &#123;
        System.out.println(&quot;房东要出租房子&quot;);
    &#125;
&#125;</code></pre>

<p>3、代理角色</p>
<pre><code class="highlight plaintext">package com.kuang.demo01;

public class Proxy implements Rent&#123;
    private Host host;

    public Proxy(Host host) &#123;
        this.host = host;
    &#125;

    public Proxy() &#123;
    &#125;

    @Override
    public void rent() &#123;
        seeHouse();
        host.rent();
        hetong();
        fare();
    &#125;

    //看房
    public void seeHouse()&#123;
        System.out.println(&quot;中介带你看房&quot;);
    &#125;

    public void hetong()&#123;
        System.out.println(&quot;中介带你签合同&quot;);
    &#125;

    //收中介费
    public void fare()&#123;
        System.out.println(&quot;收中介费&quot;);
    &#125;
&#125;</code></pre>

<p>4、客户端访问代理角色</p>
<pre><code class="highlight plaintext">public class Client &#123;
    public static void main(String[] args) &#123;
        //房东要出租房子
        Host host = new Host();
        //代理，中介帮房东租房子，一般会有附属操作（看房，签合同等）
        Proxy proxy = new Proxy(host);
        //你不用面对房东，直接找中介租房
        proxy.rent();
    &#125;
&#125;</code></pre>

<p><strong>代理模式的好处：</strong></p>
<ul>
<li>可以使真实角色的操作更加纯粹，不用去关注一些公共的业务。</li>
<li>公共业务交给代理角色，实现了业务的分工。</li>
<li>公共业务发生扩展的时候，方便集中管理。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>一个真实角色就会产生一个代理角色，代码量会翻倍，开发效率会变低。</li>
</ul>
<h3 id="10-2-加深理解"><a href="#10-2-加深理解" class="headerlink" title="10.2 加深理解"></a>10.2 加深理解</h3><p>1、接口</p>
<pre><code class="highlight plaintext">public interface UserService &#123;
    public void add();
    public void delete();
    public void update();
    public void query();
&#125;</code></pre>

<p>2、真实角色</p>
<pre><code class="highlight plaintext">//真实对象
public class UserServiceImpl implements UserService&#123;
    @Override
    public void add() &#123;
        System.out.println(&quot;增加了一个用户&quot;);
    &#125;

    @Override
    public void delete() &#123;
        System.out.println(&quot;删除了一个用户&quot;);
    &#125;

    @Override
    public void update() &#123;
        System.out.println(&quot;修改了一个用户&quot;);
    &#125;

    @Override
    public void query() &#123;
        System.out.println(&quot;查询了一个用户&quot;);
    &#125;
&#125;</code></pre>

<p>3、代理角色</p>
<pre><code class="highlight plaintext">package com.kuang.demo02;

public class UserServiceProxy implements UserService&#123;

    private UserServiceImpl userService;

    public void setUserService(UserServiceImpl userService) &#123;
        this.userService = userService;
    &#125;

    @Override
    public void add() &#123;
        log(&quot;add&quot;);userService.add();
    &#125;

    @Override
    public void delete() &#123;
        log(&quot;delete&quot;);userService.delete();
    &#125;

    @Override
    public void update() &#123;
        log(&quot;update&quot;);userService.update();
    &#125;

    @Override
    public void query() &#123;
        log(&quot;query&quot;);userService.query();
    &#125;

    //日志方法
    public void log(String msg)&#123;
        System.out.println(&quot;使用了&quot;+msg+&quot;方法&quot;);
    &#125;
&#125;</code></pre>

<p>4、客户端</p>
<pre><code class="highlight plaintext">public class Client &#123;
    public static void main(String[] args) &#123;
        UserServiceImpl userService = new UserServiceImpl();
        UserServiceProxy userServiceProxy = new UserServiceProxy();
        userServiceProxy.setUserService(userService);

        userServiceProxy.add();
    &#125;
&#125;</code></pre>

<p>通过代理模式，不需修改真实角色的原有代码，既可实现一些附属操作。</p>
<h3 id="10-3-动态代理"><a href="#10-3-动态代理" class="headerlink" title="10.3 动态代理"></a>10.3 动态代理</h3><ul>
<li>动态代理和静态代理角色一样。</li>
<li>动态代理类是动态生成的，不是直接写好的。</li>
<li>动态代理分类：基于接口 的动态代理、基于类的动态代理。<br>基于接口 —– JDK动态代理。<br>基于类 —— cglib<br>java字节码实现 —— javasist</li>
</ul>
<p><strong>两个类：</strong></p>
<ul>
<li>Proxy：代理</li>
<li>InvocationHandler：调用处理程序</li>
</ul>
<p>1、接口</p>
<pre><code class="highlight java"><span class="comment">//租房</span>
<span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Rent</span> &#123;
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rent</span><span class="params">()</span>;
&#125;
<span class="number">1234</span></code></pre>

<p>2、真实角色</p>
<pre><code class="highlight plaintext">//房东
public class Host implements Rent &#123;
    @Override
    public void rent() &#123;
        System.out.println(&quot;房东要出租房子&quot;);
    &#125;
&#125;</code></pre>

<p>3、动态代理类</p>
<pre><code class="highlight plaintext">//使用该类自动生成代理模式
public class ProxyInvocationHandler implements InvocationHandler &#123;

    //被代理的接口
    private Rent rent;

    public void setRent(Rent rent) &#123;
        this.rent = rent;
    &#125;

	//生成代理类
    public Object getProxy()&#123;
        return Proxy.newProxyInstance(this.getClass().getClassLoader(),
        							rent.getClass().getInterfaces(),this);
    &#125;

    //处理代理实例，并返回结果
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;

        //动态代理的本质就是使用反射机制。
        seeHouse();
        Object result = method.invoke(rent, args);
        fare();
        return result;
    &#125;

    public void seeHouse()&#123;
        System.out.println(&quot;中介带看房子&quot;);
    &#125;
    public void fare()&#123;
        System.out.println(&quot;收中介费&quot;);
    &#125;
&#125;</code></pre>

<p>4、客户端</p>
<pre><code class="highlight plaintext">public class Client &#123;
    public static void main(String[] args) &#123;
        //真实角色
        Host host = new Host();
        //代理角色：现在没有
        ProxyInvocationHandler pih = new ProxyInvocationHandler();
        //通过调用程序处理角色来处理我们要调用的接口对象
        pih.setRent(host); //要代理的角色
        Rent proxy = (Rent) pih.getProxy();//proxy为动态生成，并没写
        proxy.rent();
    &#125;
&#125;</code></pre>

<p><strong>动态代理工具类模板：</strong></p>
<pre><code class="highlight plaintext">//使用该类自动生成代理模式
public class ProxyInvocationHandler implements InvocationHandler &#123;

    //被代理的接口
    private Object target;

    public void setTarget(Object target) &#123;
        this.target = target;
    &#125;

    //生成代理类
    public Object getProxy()&#123;
        return Proxy.newProxyInstance(this.getClass().getClassLoader(),target.getClass().getInterfaces(),this);
    &#125;

    //处理代理实例，并返回结果
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;
        //动态代理的本质就是使用反射机制。
        log(method.getName());
        Object result = method.invoke(target, args);
        return result;
    &#125;

    //日志
    public void log(String msg)&#123;
        System.out.println(&quot;执行了：&quot;+msg+&quot;方法&quot;);
    &#125;

&#125;</code></pre>

<p>客户端</p>
<pre><code class="highlight plaintext">public class Client &#123;
    public static void main(String[] args) &#123;
        //真实角色
        UserServiceImpl userService = new UserServiceImpl();
        //代理角色，不存在
        ProxyInvocationHandler pih = new ProxyInvocationHandler();
        //设置要代理的对象
        pih.setTarget(userService);
        //动态生成代理类
        UserService proxy = (UserService) pih.getProxy();
        proxy.delete();
    &#125;
&#125;</code></pre>

<p><strong>动态代理的好处：</strong></p>
<ul>
<li>静态代理的所有好处。</li>
<li>一个动态代理类代理的是一个接口，一般就是一个对应的业务。</li>
<li>一个动态代理类可以代理多个类，只要是实现了同一个接口即可。</li>
</ul>
<h2 id="11-AOP"><a href="#11-AOP" class="headerlink" title="11. AOP"></a>11. AOP</h2><h3 id="11-1-什么是AOP"><a href="#11-1-什么是AOP" class="headerlink" title="11.1 什么是AOP"></a>11.1 什么是AOP</h3><p>AOP（Aspect Oriented Programming）意为：面向切面编程， 通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。<br><img src="https://i-blog.csdnimg.cn/blog_migrate/977114aa6feb60ec215377290c0010b8.png" alt="在这里插入图片描述"></p>
<h3 id="11-2-AOP在Spring中的作用"><a href="#11-2-AOP在Spring中的作用" class="headerlink" title="11.2 AOP在Spring中的作用"></a>11.2 AOP在Spring中的作用</h3><p><strong>提供声明式事务；允许用户自定义切面</strong></p>
<p><strong>横切关注点：</strong> 跨越应用程序多个模块的方法或功能。即是，与我们业务逻辑无关的，但是我们需要关注的部分，就是横切关注点。如日志，安全，缓存，事务等等…<br><strong>切面（ASPECT）：</strong>横切关注点被模块化的特殊对象。即，它是一个类。<br><strong>通知（Advice）：</strong>切面必须要完成的工作。即，它是类中的一个方法。<br><strong>目标（Target）：</strong>被通知对象。<br><strong>代理（Proxy）：</strong>向目标对象应用通知之后创建的对象。<br><strong>切入点（PointCut）：</strong>切面通知执行的“地点”的定义。<br><strong>连接点（JointPoint）：</strong>与切入点匹配的执行点。</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/ad74f1595b1d97d1bc9e0ce268653677.png" alt="在这里插入图片描述"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/f0ffb9e92a44edee092420088f257900.png" alt="在这里插入图片描述"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/280d34f18c32e203594d81bd2fd19f6a.png" alt="在这里插入图片描述"><br><strong>即AOP在不改变原有代码的情况下，去增加新的功能。</strong></p>
<h3 id="11-3-使用Spring实现AOP"><a href="#11-3-使用Spring实现AOP" class="headerlink" title="11.3 使用Spring实现AOP"></a>11.3 使用Spring实现AOP</h3><p>【重点】 使用AOP植入，需要导入一个依赖包。</p>
<pre><code class="highlight plaintext">&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.aspectj&lt;/groupId&gt;
        &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;
        &lt;version&gt;1.9.9&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;</code></pre>

<p><strong>方式一：使用Spring的API接口 【主要SpringAPI接口实现】</strong><br><img src="https://i-blog.csdnimg.cn/blog_migrate/721d0c72eacf16bd5e9aa3c052a2edd5.png" alt="在这里插入图片描述"></p>
<p><strong>UserService：</strong></p>
<pre><code class="highlight plaintext">package com.kuang.service;

public interface UserService &#123;
    public void add();
    public void delete();
    public void update();
    public void select();
&#125;</code></pre>

<p><strong>UserServiceImpl：</strong></p>
<pre><code class="highlight plaintext">package com.kuang.service;

public class UserServiceImpl implements UserService&#123;
    @Override
    public void add() &#123;
        System.out.println(&quot;增加了一个用户&quot;);
    &#125;

    @Override
    public void delete() &#123;
        System.out.println(&quot;删除了一个用户&quot;);
    &#125;

    @Override
    public void update() &#123;
        System.out.println(&quot;修改了一个用户&quot;);
    &#125;

    @Override
    public void select() &#123;
        System.out.println(&quot;选择了一个用户&quot;);
    &#125;
&#125;</code></pre>

<p><strong>Log：</strong></p>
<pre><code class="highlight plaintext">package com.kuang.log;

import org.springframework.aop.MethodBeforeAdvice;

import java.lang.reflect.Method;

public class Log implements MethodBeforeAdvice &#123;
    @Override
    //method:要执行的目标对象的方法
    //args：参数
    //target：目标对象
    public void before(Method method, Object[] args, Object target) throws Throwable &#123;
        System.out.println(target.getClass().getName()+&quot;的&quot;+method.getName()+&quot;被执行了&quot;);
    &#125;
&#125;</code></pre>

<p><strong>afterLog：</strong></p>
<pre><code class="highlight plaintext">package com.kuang.log;

import org.springframework.aop.AfterReturningAdvice;

import java.lang.reflect.Method;

public class AfterLog implements AfterReturningAdvice &#123;

    //returnValue：返回值
    public void afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable &#123;
        System.out.println(&quot;执行了&quot;+method.getName()+&quot;方法， 返回结果为：&quot;+returnValue);
    &#125;
&#125;</code></pre>

<p><strong>applicationContext：</strong></p>
<pre><code class="highlight plaintext">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/aop
        https://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;


	&lt;!--注册bean--&gt;
    &lt;bean id=&quot;userService&quot; class=&quot;com.kuang.service.UserServiceImpl&quot;/&gt;
    &lt;bean id=&quot;log&quot; class=&quot;com.kuang.log.Log&quot;/&gt;
    &lt;bean id=&quot;afterLog&quot; class=&quot;com.kuang.log.AfterLog&quot;/&gt;


    &lt;!--方式一：使用原生的spring API接口--&gt;
    &lt;!--配置AOP：需要导入aop的约束--&gt;
    &lt;aop:config&gt;
        &lt;!--切入点：expression：表达式，execution（要执行的位置，****）--&gt;
        &lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;/&gt;

        &lt;!--执行环绕增加--&gt;
        &lt;aop:advisor advice-ref=&quot;log&quot; pointcut-ref=&quot;pointcut&quot;/&gt;
        &lt;aop:advisor advice-ref=&quot;afterLog&quot; pointcut-ref=&quot;pointcut&quot;/&gt;
    &lt;/aop:config&gt;

&lt;/beans&gt;</code></pre>

<p><strong>MyTest：</strong></p>
<pre><code class="highlight plaintext">public class MyTest &#123;
    public static void main(String[] args) &#123;
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
        //动态代理代理是接口
        UserService userService = (UserService)context.getBean(&quot;userService&quot;);
        userService.add();
    &#125;
&#125;</code></pre>

<p><img src="https://i-blog.csdnimg.cn/blog_migrate/428a33eb390c42384809d883f18cb9e2.png" alt="在这里插入图片描述"></p>
<p><strong>定义DiyPointCut类：</strong></p>
<pre><code class="highlight plaintext">package com.kuang.diy;

public class DiyPointCut &#123;
    public void before()&#123;
        System.out.println(&quot;======方法执行前=====&quot;);
    &#125;
    public void after()&#123;
        System.out.println(&quot;======方法执行后=====&quot;);
    &#125;
&#125;</code></pre>

<p><strong>applicationContext.xml:</strong></p>
<pre><code class="highlight plaintext">&lt;!--方式二：自定义类--&gt;
   &lt;bean id=&quot;diy&quot; class=&quot;com.kuang.diy.DiyPointCut&quot;/&gt;
   &lt;aop:config&gt;
   &lt;!--自定义切面，ref要引用的类--&gt;
       &lt;aop:aspect ref=&quot;diy&quot;&gt;
           &lt;!--切入点--&gt;
           &lt;aop:pointcut id=&quot;point&quot; expression=&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;/&gt;
           &lt;!--通知--&gt;
           &lt;aop:before method=&quot;before&quot; pointcut-ref=&quot;point&quot;/&gt;
           &lt;aop:after method=&quot;after&quot; pointcut-ref=&quot;point&quot;/&gt;
       &lt;/aop:aspect&gt;
   &lt;/aop:config&gt;</code></pre>

<p><strong>测试类或接口内容不变。</strong><br><img src="https://i-blog.csdnimg.cn/blog_migrate/4310ffc24ac53bf0cf8faa26f22db776.png" alt="在这里插入图片描述"></p>
<p><strong>方式三：使用注解实现</strong></p>
<p><strong>自定义类：AnnotationPointCut</strong></p>
<pre><code class="highlight plaintext">package com.kuang.diy;

import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.Signature;
import org.aspectj.lang.annotation.After;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;

//方式三：使用注解方式实现AOP
@Aspect //标注该类为切面
public class AnnotationPointCut &#123;
    @Before(&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;)
    public void before()&#123;
        System.out.println(&quot;======方法执行前=====&quot;);
    &#125;

    @After(&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;)
    public void after()&#123;
        System.out.println(&quot;======方法执行后=====&quot;);
    &#125;

    //在环绕增强中，可以给定一个参数，代表我们要获取处理切入的点
    @Around(&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;)
    public void around(ProceedingJoinPoint jp) throws Throwable&#123;
        System.out.println(&quot;环绕前&quot;);
        Signature signature = jp.getSignature();
        System.out.println(&quot;signature&quot;+signature);

        Object proceed = jp.proceed(); //执行方法
        System.out.println(&quot;环绕后&quot;);

        System.out.println(proceed);
    &#125;
&#125;</code></pre>

<p><strong>applicationContext.xml</strong></p>
<pre><code class="highlight plaintext">&lt;!--方式三：使用注解的方式--&gt;
&lt;bean id=&quot;annotationPointCut&quot; class=&quot;com.kuang.diy.AnnotationPointCut&quot;/&gt;
&lt;!--开启注解支持--&gt;
&lt;aop:aspectj-autoproxy/&gt;</code></pre>

<p><img src="https://i-blog.csdnimg.cn/blog_migrate/58be31f018e1885b339e28095e43ff49.png" alt="在这里插入图片描述"></p>
<h2 id="12-整合Mybatis"><a href="#12-整合Mybatis" class="headerlink" title="12. 整合Mybatis"></a>12. 整合Mybatis</h2><p>步骤：</p>
<ol>
<li>导入相关jar包<br>junit、mybatis、mysql数据库、spring相关的、aop植入、mybatis-spring</li>
<li>编写配置文件</li>
<li>测试</li>
</ol>
<h3 id="12-1-回忆Mybatis"><a href="#12-1-回忆Mybatis" class="headerlink" title="12.1 回忆Mybatis"></a>12.1 回忆Mybatis</h3><p>1、编写实体类</p>
<pre><code class="highlight plaintext">package com.kuang.pojo;

import lombok.Data;

@Data
public class User &#123;
    private int id;
    private String name;
    private String pwd;
&#125;</code></pre>

<p>2、编写核心配置文件</p>
<pre><code class="highlight plaintext">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE configuration
        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;
&lt;configuration&gt;
    
    &lt;typeAliases&gt;
        &lt;package name=&quot;com.kuang.pojo&quot;/&gt;
    &lt;/typeAliases&gt;

    &lt;environments default=&quot;development&quot;&gt;
        &lt;environment id=&quot;development&quot;&gt;
            &lt;transactionManager type=&quot;JDBC&quot;/&gt;
            &lt;dataSource type=&quot;POOLED&quot;&gt;
                &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;
                &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=false&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8&quot;/&gt;
                &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
                &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt;
            &lt;/dataSource&gt;
        &lt;/environment&gt;
    &lt;/environments&gt;

    &lt;mappers&gt;
        &lt;package name=&quot;com.kuang.mapper&quot;/&gt;
    &lt;/mappers&gt;
    
&lt;/configuration&gt;</code></pre>

<p>3、编写接口</p>
<pre><code class="highlight plaintext">package com.kuang.mapper;

import com.kuang.pojo.User;

import java.util.List;

public interface UserMapper &#123;
    public List&lt;User&gt; selectUser();
&#125;</code></pre>

<p>4、编写Mapper.xml文件</p>
<pre><code class="highlight plaintext">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.kuang.mapper.UserMapper&quot;&gt;
    &lt;select id=&quot;selectUser&quot; resultType=&quot;user&quot;&gt;
        select * from mybatis.user
    &lt;/select&gt;
&lt;/mapper&gt;</code></pre>

<p>5、测试</p>
<pre><code class="highlight plaintext">public class MyTest &#123;
    @Test
    public void selectUser() throws IOException &#123;
        String resources = &quot;mybatis-config.xml&quot;;
        InputStream in = Resources.getResourceAsStream(resources);
        SqlSessionFactory build = new SqlSessionFactoryBuilder().build(in);
        SqlSession sqlSession = build.openSession(true);

        UserMapper mapper = sqlSession.getMapper(UserMapper.class);
        List&lt;User&gt; userList = mapper.selectUser();

        for (User user : userList) &#123;
            System.out.println(user);
        &#125;

        sqlSession.close();

    &#125;
&#125;</code></pre>

<h3 id="12-2-Mybatis-Spring"><a href="#12-2-Mybatis-Spring" class="headerlink" title="12.2 Mybatis-Spring"></a>12.2 Mybatis-Spring</h3><p>MyBatis-Spring 会帮助你将 MyBatis 代码无缝地整合到 Spring 中。</p>
<p>文档链接：<a target="_blank" rel="noopener" href="http://mybatis.org/spring/zh/index.html">http://mybatis.org/spring/zh/index.html</a></p>
<p>如果使用 Maven 作为构建工具，仅需要在 pom.xml 中加入以下代码即可：</p>
<pre><code class="highlight plaintext">&lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis-spring --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
    &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;
    &lt;version&gt;2.0.2&lt;/version&gt;
&lt;/dependency&gt;</code></pre>

<p><strong>整合实现方式一：</strong></p>
<p>1、引入Spring配置文件spring-dao.xml</p>
<pre><code class="highlight plaintext">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/aop
        https://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;

&lt;!--    第一步：配置数据源替换mybatis的数据源--&gt;

    &lt;!--DataSource: 使用spring的数据源替换mybatis的配置
        此处使用spring提供的jdbc：org.springframework.jdbc.datasource--&gt;
    &lt;bean id=&quot;datasource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;
        &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;
        &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=false&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8&quot;/&gt;
        &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
        &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt;
    &lt;/bean&gt;

&lt;!--    第二步：配置SqlSessionFactory，关联Mybatis--&gt;

    &lt;!--sqlSessionFactory--&gt;
    &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;datasource&quot;/&gt;
        &lt;!--绑定Mybatis配置文件--&gt;
        &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;/&gt;
        &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:com/kuang/mapper/*.xml&quot;/&gt;
    &lt;/bean&gt;

&lt;!--    第三步：注册sqlSessionTemplate，关联sqlSessionFactory--&gt;
    
    &lt;!--SqlSessionTemplate: 就是我们使用的sqlSession--&gt;
    &lt;bean id=&quot;sqlSession&quot; class=&quot;org.mybatis.spring.SqlSessionTemplate&quot;&gt;
        &lt;!--只能使用构造器注入sqlSessionFactory,因为其没有set方法--&gt;
        &lt;constructor-arg index=&quot;0&quot; ref=&quot;sqlSessionFactory&quot;/&gt;
    &lt;/bean&gt;


&lt;/beans&gt;</code></pre>

<p>2、编写UserMapper接口的实现类UserMapperImpl，私有化sqlSessionTemplate</p>
<pre><code class="highlight plaintext">package com.kuang.mapper;

import com.kuang.pojo.User;
import org.mybatis.spring.SqlSessionTemplate;

import java.util.List;

public class UserMapperImpl implements UserMapper&#123;
    //我们所有操作，都使用sqlSession来执行，在原来，现在都使用SqlSessionTemplate
    private SqlSessionTemplate sqlSession;

    public void setSqlSession(SqlSessionTemplate sqlSession) &#123;
        this.sqlSession = sqlSession;
    &#125;

    @Override
    public List&lt;User&gt; selectUser() &#123;
        UserMapper mapper = sqlSession.getMapper(UserMapper.class);
        return mapper.selectUser();
    &#125;
&#125;</code></pre>

<p>3、将自己编写的实现类，注入到spring-dao配置文件中</p>
<pre><code class="highlight plaintext">&lt;bean id=&quot;userMapper&quot; class=&quot;com.kuang.mapper.UserMapperImpl&quot;&gt;
    &lt;property name=&quot;sqlSession&quot; ref=&quot;sqlSession&quot;/&gt;
&lt;/bean&gt;</code></pre>

<p>4、测试</p>
<pre><code class="highlight plaintext">public class MyTest &#123;
    @Test
    public void selectUser() throws IOException &#123;
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;spring-dao.xml&quot;);
        UserMapper userMapper = context.getBean(&quot;userMapper&quot;, UserMapper.class);
        for (User user : userMapper.selectUser()) &#123;
            System.out.println(user);
        &#125;
    &#125;
&#125;</code></pre>

<p>整合后，mybatis-config.xml配置文件内容如下：</p>
<pre><code class="highlight plaintext">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE configuration
        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;
&lt;configuration&gt;
    
    &lt;typeAliases&gt;
        &lt;package name=&quot;com.kuang.pojo&quot;/&gt;
    &lt;/typeAliases&gt;

    
&lt;/configuration&gt;</code></pre>

<p><strong>整合实现方式二</strong></p>
<p>1、修改方式一中的UserMapperImpl文件</p>
<pre><code class="highlight plaintext">public class UserMapperImpl2 extends SqlSessionDaoSupport implements UserMapper &#123;
    @Override
    public List&lt;User&gt; selectUser() &#123;
        return getSqlSession().getMapper(UserMapper.class).selectUser();
    &#125;
&#125;</code></pre>

<p>2、注册到spring配置文件中</p>
<pre><code class="highlight plaintext">&lt;bean id=&quot;userMapper2&quot; class=&quot;com.kuang.mapper.UserMapperImpl2&quot;&gt;
    &lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot;/&gt;
&lt;/bean&gt;</code></pre>

<p>3、测试</p>
<pre><code class="highlight plaintext">public class MyTest &#123;
    @Test
    public void selectUser() throws IOException &#123;
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;spring-dao.xml&quot;);
        UserMapper userMapper = context.getBean(&quot;userMapper2&quot;, UserMapper.class);
        for (User user : userMapper.selectUser()) &#123;
            System.out.println(user);
        &#125;
    &#125;
&#125;</code></pre>

<p>注意：</p>
<p>可以编写总配置文件applicationContext.xml，将spring-dao.xml导入其中。<br>此时，自己编写的实现类，可以直接在applicationContext中编写注入。<br>在测试类中，可使用new ClassPathXmlApplicationContext(“applicationContext.xml”)。</p>
<p><strong>applicationContext.xml</strong></p>
<pre><code class="highlight plaintext">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/aop
        https://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;

    &lt;import resource=&quot;spring-dao.xml&quot;/&gt;

    &lt;bean id=&quot;userMapper&quot; class=&quot;com.kuang.mapper.UserMapperImpl&quot;&gt;
        &lt;property name=&quot;sqlSession&quot; ref=&quot;sqlSession&quot;/&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;userMapper2&quot; class=&quot;com.kuang.mapper.UserMapperImpl2&quot;&gt;
        &lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot;/&gt;
    &lt;/bean&gt;

&lt;/beans&gt;</code></pre>

<p><strong>测试类：</strong></p>
<pre><code class="highlight plaintext">ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</code></pre>

<h2 id="13-声明式事务"><a href="#13-声明式事务" class="headerlink" title="13. 声明式事务"></a>13. 声明式事务</h2><h3 id="13-1-回顾事务"><a href="#13-1-回顾事务" class="headerlink" title="13.1 回顾事务"></a>13.1 回顾事务</h3><ul>
<li>把一组业务当成一个业务来做，要么都成功，要么都失败。</li>
<li>事务在项目开发中，十分重要，涉及到数据的一致性问题，不容马虎。</li>
<li>确保完整性和一致性。</li>
</ul>
<p><strong>事务ACID原则：</strong></p>
<ul>
<li>原子性</li>
<li>一致性</li>
<li>隔离性</li>
<li>持久性</li>
</ul>
<p><strong>测试：</strong></p>
<p>利用上面案例的代码新建一个项目，为userMapper接口新增两个方法，删除和增加用户；</p>
<pre><code class="highlight plaintext">public interface UserMapper &#123;
    public List&lt;User&gt; selectUser();

    //添加一个用户
    public int addUser(User user);

    //删除一个用户
    public int deleteUser(int id);
&#125;</code></pre>

<p>UserMapper文件中，故意将deletes写错，测试是否能够删除。</p>
<pre><code class="highlight plaintext">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.kuang.mapper.UserMapper&quot;&gt;
    &lt;select id=&quot;selectUser&quot; resultType=&quot;user&quot;&gt;
        select * from mybatis.user
    &lt;/select&gt;

    &lt;insert id=&quot;addUser&quot; parameterType=&quot;user&quot;&gt;
        insert into mybatis.user (id,name,pwd) values (#&#123;id&#125;,#&#123;name&#125;,#&#123;pwd&#125;)
    &lt;/insert&gt;

    &lt;delete id=&quot;deleteUser&quot; parameterType=&quot;int&quot;&gt;
        delete from mybatis.user where id = #&#123;id&#125;
    &lt;/delete&gt;
    
&lt;/mapper&gt;</code></pre>

<p>编写接口的UserMapperImpl实现类</p>
<pre><code class="highlight plaintext">package com.kuang.mapper;

import com.kuang.pojo.User;
import org.mybatis.spring.SqlSessionTemplate;
import org.mybatis.spring.support.SqlSessionDaoSupport;

import java.util.List;

public class UserMapperImpl extends SqlSessionDaoSupport implements UserMapper&#123;

    @Override
    public List&lt;User&gt; selectUser() &#123;

        User user = new User(12, &quot;xiaowang&quot;, &quot;23244&quot;);
        UserMapper mapper = getSqlSession().getMapper(UserMapper.class);
        mapper.addUser(user);
        mapper.deleteUser(4);
        return mapper.selectUser();
    &#125;

    @Override
    public int addUser(User user) &#123;
        return getSqlSession().getMapper(UserMapper.class).addUser(user);
    &#125;

    @Override
    public int deleteUser(int id) &#123;
        return getSqlSession().getMapper(UserMapper.class).deleteUser(id);
    &#125;
&#125;</code></pre>

<p>测试类：</p>
<pre><code class="highlight plaintext">public class MyTest &#123;
    public static void main(String[] args) &#123;
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
        UserMapper userMapper = context.getBean(&quot;userMapper&quot;, UserMapper.class);

        List&lt;User&gt; userList = userMapper.selectUser();
        for (User user : userList) &#123;
            System.out.println(user);
        &#125;
    &#125;
&#125;</code></pre>

<p>测试结果：sql异常，delete错误，但数据库中成功插入数据，无法删除。<br>Spring中提供了事务管理，只需要配置即可。</p>
<h3 id="13-2-Spring中的事务管理"><a href="#13-2-Spring中的事务管理" class="headerlink" title="13.2 Spring中的事务管理"></a>13.2 Spring中的事务管理</h3><p>Spring在不同的事务管理API之上定义了一个抽象层，使得开发人员不必了解底层的事务管理API就可以使用Spring的事务管理机制。Spring支持编程式事务管理和声明式的事务管理。</p>
<p><strong>编程式事务管理</strong></p>
<p>-将事务管理代码嵌到业务方法中来控制事务的提交和回滚。<br>-缺点：必须在每个事务操作业务逻辑中包含额外的事务管理代码。</p>
<p><strong>声明式事务管理</strong></p>
<ul>
<li>一般情况下比编程式事务好用。</li>
<li>将事务管理代码从业务方法中分离出来，以声明的方式来实现事务管理。</li>
<li>将事务管理作为横切关注点，通过aop方法模块化。Spring中通过Spring AOP框架支持声明式事务管理。</li>
</ul>
<p><strong>1. 使用Spring事务管理，需要在spring-dao.xml中导入头文件的约束：tx</strong></p>
<pre><code class="highlight plaintext">xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;

http://www.springframework.org/schema/tx
http://www.springframework.org/schema/tx/spring-tx.xsd&quot;</code></pre>

<p><strong>2. 配置声明事务 spring-dao.xml</strong></p>
<pre><code class="highlight plaintext">&lt;!--配置声明式事务--&gt;
&lt;bean id=&quot;transactionManager&quot; 					  class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;
    &lt;property name=&quot;dataSource&quot; ref=&quot;datasource&quot;/&gt;
&lt;/bean&gt;
</code></pre>

<p><strong>3. 配置事务的通知 spring-dao.xml</strong></p>
<pre><code class="highlight plaintext">&lt;!--结合AOP实现事务的植入--&gt;
&lt;!--配置事务通知--&gt;
&lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;
    &lt;!--给哪些方法配置事务--&gt;
    &lt;!--配置事务的传播特性： new propagation--&gt;
    &lt;tx:attributes&gt;
        &lt;tx:method name=&quot;add&quot; propagation=&quot;REQUIRED&quot;/&gt;
        &lt;tx:method name=&quot;delete&quot; propagation=&quot;REQUIRED&quot;/&gt;
        &lt;tx:method name=&quot;update&quot; propagation=&quot;REQUIRED&quot;/&gt;
        &lt;tx:method name=&quot;query&quot; propagation=&quot;REQUIRED&quot;/&gt;
        &lt;!--正常写下面一行即可：配置全部的方法--&gt;
        &lt;tx:method name=&quot;*&quot; propagation=&quot;REQUIRED&quot;/&gt;
    &lt;/tx:attributes&gt;
&lt;/tx:advice&gt;</code></pre>

<p><strong>4. 配置事务切入 spring-dao.xml</strong></p>
<pre><code class="highlight plaintext">&lt;!--配置事务切入--&gt;
&lt;aop:config&gt;
    &lt;aop:pointcut id=&quot;txPointCut&quot; expression=&quot;execution(* com.kuang.mapper.*.*(..))&quot;/&gt;
    &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;txPointCut&quot;/&gt;
&lt;/aop:config&gt;
</code></pre>

<p><strong>5.测试</strong></p>
<pre><code class="highlight plaintext">public class MyTest &#123;
    public static void main(String[] args) &#123;
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
        UserMapper userMapper = context.getBean(&quot;userMapper&quot;, UserMapper.class);

        List&lt;User&gt; userList = userMapper.selectUser();
        for (User user : userList) &#123;
            System.out.println(user);
        &#125;
    &#125;
&#125;</code></pre>



<h2 id="14-总结"><a href="#14-总结" class="headerlink" title="14. 总结"></a>14. 总结</h2><p>1、Spring的核心：控制反转（IOC）和面向切面编程（AOP）。</p>
<p>2、在Spring中，创建一个实体类后，需要在Spring的核心配置文件(**.xml)中，通过bean的方式进行注册。相当于一个大容器中有了各类的对象，想用的时候直接取就行。</p>
<p>3、IOC利用有参构造创建对象的三种方式：下标赋值、类型创建、参数名。无参构造直接赋值即可。</p>
<p>4、在配置文件中通过bean的方式注册类，就和java中通过new的方式生成对象类似。</p>
<p>5、类取别名：alias。多个配置文件的合并：import。</p>
<p>6、依赖注入：就相当于给类中的属性进行赋值。注入方式有：通过构造器的方式、通过set方法的方式。通过set的方式需要类里面有相应属性的set方法。可以给多种类型参数赋值：普通值、数组、集合等。</p>
<p>7、P命名空间给属性赋值（直接注入）、C命名空间给属性赋值（利用构造器）。使用前需要导入xml约束。</p>
<p>8、Bean的作用域（scope）：单例模式（singleton）和原型模式（prototype）。</p>
<p>9、Bean自动装配：Spring在容器或上下文中自动寻找，并自动给bean匹配属性。byName：利用bean的id确定匹配，而byType利用bean的class确定匹配。同时，可以使用注解@Autowired和@Resources来进行自动装配，前提要在核心配置文件中开启注解的支持。</p>
<p>10、使用注解开发：需要导入AOP的包和开启注解支持。在类的上面加上@Component等同于在核心配置文件中注册bean，在属性的上面加上@value（*）可以直接对属性值注入。</p>
<p>11、使用Java配置Spring：在类的上面加上@Configuration代表该类为配置类，在类中方法的上面加上@Bean类似在核心配置文件中注册，方法名相当于bean中的id，返回值等同于bean中的class属性。</p>
<p>12、代理模式包括的角色：抽象角色（接口或抽象类）、真实角色、代理角色、客户。真实角色和代理角色要实现同一个接口。代理角色可以增加一些额外的操作，而真实角色的代码不用修改。静态代理：一个真实角色需要一个代理角色进行针对性的管理。动态代理：代理类是动态生成的，可以定义生成代理类的工具类，一个动态代理类可以代理多个类，只要实现了同一个接口。</p>
<p>13、Spring实现AOP：实现了在执行方法前和后，可以自定义一些操作。方式有：① 实现API的接口（类似MethodBeforeAdvice和AfterReturningAdvice），在核心配置文件中配置AOP，设定切入点和执行环绕增加。 ② 自定义类实现AOP（主要是切面定义），在核心配置文件中定义切面、切入点和方法通知。 ③ 使用注解实现：自定义类，标注为切面，对方法进行标注，开启注解。</p>
<p>14、Spring和Mybatis的整合：固定模板。</p>
<p>15、Spring中有针对事务的管理办法，在核心配置文件中配置事务的通知即可（固定模板）。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://xz613.github.io">John Doe</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://xz613.github.io/2025/03/11/%E7%8B%82%E7%A5%9Espring5/">https://xz613.github.io/2025/03/11/%E7%8B%82%E7%A5%9Espring5/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://xz613.github.io" target="_blank">他乡遇故知</a>！</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="/img/avator.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.4/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.4/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/03/11/Spring%E7%AC%94%E8%AE%B0/" title="Spring笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Spring笔记</div></div><div class="info-2"><div class="info-item-1">Spring笔记IOC对象创建的方式：AOP实现方式AOP:面向切面编程：spring 框架用动态代理技术来支持面像切面编程，spring的动态代理有两种方式： 1、JDK动态代理：基于接口的代理 2、CGLB代理：基于类的代理 需要了解两个类：  proxy ：代理 InvocationHandler ：调用处理程序  ​	Invocation Handler内部只有一个方法 object invoke(objecT proxy,method, object[] args)throws throwable 1、JDK动态代理 ​	JDK动态代理是 Java 本身提供的代理机制，要求目标类必须实现接口。Spring 会创建一个目标接口的代理对象，在该对象上执行方法时，实际回委托给InvocationHandler处理。 回顾ServletServlet 是 Java 编程语言中的一种服务器端技术，用于扩展服务器的功能，尤其是在 Web 应用程序中。它们可以响应客户端（通常是浏览器）发出的请求，并生成动态的 Web 内容。Servlets 是 Java EE（现 Jakarta...</div></div></div></a><a class="pagination-related" href="/2025/03/11/springboot%E7%AC%94%E8%AE%B0%E5%B0%8F%E7%BB%93/" title="springboot笔记小结"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">springboot笔记小结</div></div><div class="info-2"><div class="info-item-1">springboot 文档参考连接：Springboot知识体系详解：https://www.pdai.tech/md/spring/springboot/springboot.html Springboot官网：https://spring.io/projects/spring-boot 博客：springboot 开发 实战开发：[Spring Boot 实战开发](https://learn.lianglianglee.com/专栏/Spring Boot 实战开发) 一，什么是SpringBootSpring Boot 是一个基于Spring 框架的开源Java开发框架，它用于简化Spring应用的配置和部署。它的目标是让开发者能够过更轻松地创建基于Spring的应用程序，并减少了配置和复杂的开发流程。SpringBoot 通过以下几个特性来实现简化开发。 1，自动配置：Spring Boot 会通过配置应用所需的许多组件，开发者不需要手动配置和定义Bean，Spring Boot会根据项目中的依赖自动进行配置。 2，内嵌的服务器：Spring Boot...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/avator.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">John Doe</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">9</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>关注我</span></a><div class="card-info-social-icons"><a class="social-icon" href="/13048559773@163.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">这是我的博客</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95%E6%A0%87%E9%A2%98"><span class="toc-number">1.</span> <span class="toc-text">目录标题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Spring"><span class="toc-number"></span> <span class="toc-text">1.Spring</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E7%AE%80%E4%BB%8B"><span class="toc-number">1.</span> <span class="toc-text">1.1 简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E4%BC%98%E7%82%B9"><span class="toc-number">2.</span> <span class="toc-text">1.2 优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E7%BB%84%E6%88%90"><span class="toc-number">3.</span> <span class="toc-text">1.3 组成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-%E6%8B%93%E5%B1%95"><span class="toc-number">4.</span> <span class="toc-text">1.4 拓展</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-IOC%E7%90%86%E8%AE%BA%E6%8E%A8%E5%AF%BC"><span class="toc-number"></span> <span class="toc-text">2. IOC理论推导</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-HelloSpring"><span class="toc-number"></span> <span class="toc-text">3.HelloSpring</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-IOC%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number"></span> <span class="toc-text">4. IOC创建对象的方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-Spring%E9%85%8D%E7%BD%AE"><span class="toc-number"></span> <span class="toc-text">5. Spring配置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E5%8F%96%E5%88%AB%E5%90%8D"><span class="toc-number">1.</span> <span class="toc-text">5.1 取别名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-Bean%E7%9A%84%E9%85%8D%E7%BD%AE"><span class="toc-number">2.</span> <span class="toc-text">5.2 Bean的配置</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5"><span class="toc-number"></span> <span class="toc-text">6. 依赖注入</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%E6%9E%84%E9%80%A0%E5%99%A8%E6%B3%A8%E5%85%A5"><span class="toc-number">1.</span> <span class="toc-text">6.1 构造器注入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-Set%E6%96%B9%E5%BC%8F%E6%B3%A8%E5%85%A5%E3%80%90%E9%87%8D%E7%82%B9%E3%80%91"><span class="toc-number">2.</span> <span class="toc-text">6.2 Set方式注入【重点】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-%E6%8B%93%E5%B1%95%E6%96%B9%E5%BC%8F%E6%B3%A8%E5%85%A5"><span class="toc-number">3.</span> <span class="toc-text">6.3 拓展方式注入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-Bean%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">4.</span> <span class="toc-text">6.4 Bean作用域</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-Bean%E7%9A%84%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D"><span class="toc-number"></span> <span class="toc-text">7. Bean的自动装配</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-%E6%B5%8B%E8%AF%95"><span class="toc-number">1.</span> <span class="toc-text">7.1 测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-ByName%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D"><span class="toc-number">2.</span> <span class="toc-text">7.2 ByName自动装配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-ByType%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D"><span class="toc-number">3.</span> <span class="toc-text">7.3 ByType自动装配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-%E4%BD%BF%E7%94%A8%E6%B3%A8%E8%A7%A3%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D"><span class="toc-number">4.</span> <span class="toc-text">7.4 使用注解实现自动装配</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E4%BD%BF%E7%94%A8%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91"><span class="toc-number"></span> <span class="toc-text">8. 使用注解开发</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E7%94%A8JAVA%E7%9A%84%E6%96%B9%E5%BC%8F%E9%85%8D%E7%BD%AESpring"><span class="toc-number"></span> <span class="toc-text">9. 用JAVA的方式配置Spring</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F"><span class="toc-number"></span> <span class="toc-text">10. 代理模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-1-%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-number">1.</span> <span class="toc-text">10.1 静态代理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-2-%E5%8A%A0%E6%B7%B1%E7%90%86%E8%A7%A3"><span class="toc-number">2.</span> <span class="toc-text">10.2 加深理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-3-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-number">3.</span> <span class="toc-text">10.3 动态代理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-AOP"><span class="toc-number"></span> <span class="toc-text">11. AOP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11-1-%E4%BB%80%E4%B9%88%E6%98%AFAOP"><span class="toc-number">1.</span> <span class="toc-text">11.1 什么是AOP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-2-AOP%E5%9C%A8Spring%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">2.</span> <span class="toc-text">11.2 AOP在Spring中的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-3-%E4%BD%BF%E7%94%A8Spring%E5%AE%9E%E7%8E%B0AOP"><span class="toc-number">3.</span> <span class="toc-text">11.3 使用Spring实现AOP</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-%E6%95%B4%E5%90%88Mybatis"><span class="toc-number"></span> <span class="toc-text">12. 整合Mybatis</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#12-1-%E5%9B%9E%E5%BF%86Mybatis"><span class="toc-number">1.</span> <span class="toc-text">12.1 回忆Mybatis</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-2-Mybatis-Spring"><span class="toc-number">2.</span> <span class="toc-text">12.2 Mybatis-Spring</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1"><span class="toc-number"></span> <span class="toc-text">13. 声明式事务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#13-1-%E5%9B%9E%E9%A1%BE%E4%BA%8B%E5%8A%A1"><span class="toc-number">1.</span> <span class="toc-text">13.1 回顾事务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-2-Spring%E4%B8%AD%E7%9A%84%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86"><span class="toc-number">2.</span> <span class="toc-text">13.2 Spring中的事务管理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-%E6%80%BB%E7%BB%93"><span class="toc-number"></span> <span class="toc-text">14. 总结</span></a></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/11/springboot%E7%AC%94%E8%AE%B0%E5%B0%8F%E7%BB%93/" title="springboot笔记小结">springboot笔记小结</a><time datetime="2025-03-11T11:20:40.000Z" title="发表于 2025-03-11 19:20:40">2025-03-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/11/%E7%8B%82%E7%A5%9Espring5/" title="狂神spring5">狂神spring5</a><time datetime="2025-03-11T11:14:04.000Z" title="发表于 2025-03-11 19:14:04">2025-03-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/11/Spring%E7%AC%94%E8%AE%B0/" title="Spring笔记">Spring笔记</a><time datetime="2025-03-11T11:12:33.000Z" title="发表于 2025-03-11 19:12:33">2025-03-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/11/Mybatis%E9%BB%91%E9%A9%AC%E7%AC%94%E8%AE%B0/" title="Mybatis黑马笔记">Mybatis黑马笔记</a><time datetime="2025-03-11T11:06:54.000Z" title="发表于 2025-03-11 19:06:54">2025-03-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/11/Redis%E5%B0%8F%E7%BB%93/" title="Redis小结">Redis小结</a><time datetime="2025-03-11T11:00:26.000Z" title="发表于 2025-03-11 19:00:26">2025-03-11</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By John Doe</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.3.5"></script><script src="/js/main.js?v=5.3.5"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (false) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.4.1/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>