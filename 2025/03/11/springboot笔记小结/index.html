<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>springboot笔记小结 | 他乡遇故知</title><meta name="author" content="John Doe"><meta name="copyright" content="John Doe"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="springboot 文档参考连接：Springboot知识体系详解：https:&#x2F;&#x2F;www.pdai.tech&#x2F;md&#x2F;spring&#x2F;springboot&#x2F;springboot.html Springboot官网：https:&#x2F;&#x2F;spring.io&#x2F;projects&#x2F;spring-boot 博客：springboot 开发 实战开发：[Spring Boot 实战开发](https:&#x2F;&#x2F;learn">
<meta property="og:type" content="article">
<meta property="og:title" content="springboot笔记小结">
<meta property="og:url" content="https://xz613.github.io/2025/03/11/springboot%E7%AC%94%E8%AE%B0%E5%B0%8F%E7%BB%93/index.html">
<meta property="og:site_name" content="他乡遇故知">
<meta property="og:description" content="springboot 文档参考连接：Springboot知识体系详解：https:&#x2F;&#x2F;www.pdai.tech&#x2F;md&#x2F;spring&#x2F;springboot&#x2F;springboot.html Springboot官网：https:&#x2F;&#x2F;spring.io&#x2F;projects&#x2F;spring-boot 博客：springboot 开发 实战开发：[Spring Boot 实战开发](https:&#x2F;&#x2F;learn">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://xz613.github.io/img/avator.png">
<meta property="article:published_time" content="2025-03-11T11:20:40.000Z">
<meta property="article:modified_time" content="2025-03-11T11:21:02.738Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://xz613.github.io/img/avator.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "springboot笔记小结",
  "url": "https://xz613.github.io/2025/03/11/springboot%E7%AC%94%E8%AE%B0%E5%B0%8F%E7%BB%93/",
  "image": "https://xz613.github.io/img/avator.png",
  "datePublished": "2025-03-11T11:20:40.000Z",
  "dateModified": "2025-03-11T11:21:02.738Z",
  "author": [
    {
      "@type": "Person",
      "name": "John Doe",
      "url": "https://xz613.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://xz613.github.io/2025/03/11/springboot%E7%AC%94%E8%AE%B0%E5%B0%8F%E7%BB%93/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.3.5"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.7.2/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'springboot笔记小结',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background: [object Object];"></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background: [object Object];"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/img/avator.png" alt="Logo"><span class="site-name">他乡遇故知</span></a><a class="nav-page-title" href="/"><span class="site-name">springboot笔记小结</span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">springboot笔记小结</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-03-11T11:20:40.000Z" title="发表于 2025-03-11 19:20:40">2025-03-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-03-11T11:21:02.738Z" title="更新于 2025-03-11 19:21:02">2025-03-11</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">8.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>38分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h3 id="springboot-文档参考连接："><a href="#springboot-文档参考连接：" class="headerlink" title="springboot 文档参考连接："></a>springboot 文档参考连接：</h3><p>Springboot知识体系详解：<a target="_blank" rel="noopener" href="https://www.pdai.tech/md/spring/springboot/springboot.html">https://www.pdai.tech/md/spring/springboot/springboot.html</a></p>
<p>Springboot官网：<a target="_blank" rel="noopener" href="https://spring.io/projects/spring-boot">https://spring.io/projects/spring-boot</a></p>
<p>博客：<a target="_blank" rel="noopener" href="https://www.liaoxuefeng.com/wiki/1252599548343744/1282386201411617">springboot 开发</a></p>
<p>实战开发：[Spring Boot 实战开发](<a target="_blank" rel="noopener" href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/Spring">https://learn.lianglianglee.com/专栏/Spring</a> Boot 实战开发)</p>
<h3 id="一，什么是SpringBoot"><a href="#一，什么是SpringBoot" class="headerlink" title="一，什么是SpringBoot"></a>一，什么是SpringBoot</h3><p>Spring Boot 是一个基于Spring 框架的开源Java开发框架，它用于简化Spring应用的配置和部署。它的目标是让开发者能够过更轻松地创建基于Spring的应用程序，并减少了配置和复杂的开发流程。SpringBoot 通过以下几个特性来实现简化开发。</p>
<p><strong>1，自动配置：</strong>Spring Boot 会通过配置应用所需的许多组件，开发者不需要手动配置和定义Bean，Spring Boot会根据项目中的依赖自动进行配置。</p>
<p><strong>2，内嵌的服务器：</strong>Spring Boot 可以直接将应用部署为可执行的JAR文件，内嵌如 Tomcat，Jetty等web服务器，免去外部服务器的配置和依赖。</p>
<p><strong>3，约定大于配置：</strong>Spring Boot 提供了许多默认的配置，帮助开发者减少了手动配置的复杂性，只需要做出少量修改即可。</p>
<p><strong>4，开箱即用：</strong>SpringBoot 提供了一系列的开箱即用功能，例如Aucuator（用于监控和管理），Spring Data Spring Security等。</p>
<p><strong>5，Spring Boot Starter:</strong> 这是一些预配置的模块，涵盖了Web开发，数据访问，消息传递等常见功能，极大的简化了构建应用的过程。</p>
<p><strong>6，命令行界面(CLI):</strong> Spring Boot 也提供了命令行界面（CLI）,让你能快速的通过脚本或命令行创建应用。</p>
<h3 id="二，什么是微服务架构？"><a href="#二，什么是微服务架构？" class="headerlink" title="二，什么是微服务架构？"></a><strong>二，什么是微服务架构？</strong></h3><p>微服务架构（Microservices Architecture）是一种设计和构建软件的方法，它将一个大型的，复杂的应用拆解成一组小的，独立的服务。每个微服务都专注于一组小的，独立的服务。每个微服务都专注于一个特定的功能或者业务逻辑，并且可以独立开发，部署，扩展，和维护。微服务之间通过轻量级的通信机制 (通常是 HTTP&#x2F;REST 或者消息队列) 进行交互。</p>
<h3 id="三，SpringBoot-快速创建"><a href="#三，SpringBoot-快速创建" class="headerlink" title="三，SpringBoot 快速创建"></a>三，SpringBoot 快速创建</h3><p>1，修改端口号</p>
<p>resources&#x2F;application.properties	 server.port &#x3D; 8081</p>
<p>2,修改bannner</p>
<p>添加 resources&#x2F;banner.txt  内部存放logo 图片。</p>
<h3 id="四，原理初探"><a href="#四，原理初探" class="headerlink" title="四，原理初探"></a>四，原理初探</h3><h4 id="1，自动装配"><a href="#1，自动装配" class="headerlink" title="1，自动装配"></a>1，自动装配</h4><p>pom.xml</p>
<ul>
<li>spring-boot-dependencies：核心依赖在父工程中！</li>
<li>我们再写或者映入SpringBoot 的时候不需要指定版本，就是因为有这些版本仓库。</li>
</ul>
<h4 id="2，启动器"><a href="#2，启动器" class="headerlink" title="2，启动器"></a>2，启动器</h4><ul>
<li><pre><code>&lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;
&lt;/dependency&gt;
<pre><code class="highlight plaintext">
- 启动器：就是Springboot 的启动场景

- 比如 spring-boot-starter-web，它会帮我们自动导入所有web环境需要的依赖。

- Spring 会将所有需要的功能场景变成一个一个的启动器。

- 我们需要什么功能，就找到对应的启动器就好了  ‘starter’



#### 3，主程序
</code></pre>
@SpringBootApplication   //标注这个应用是一个springboot 应用
public class SpringBoot01HelloApplication &#123;

  public static void main(String[] args) &#123;
  
      //将springboot应用启动
      SpringApplication.run(SpringBoot01HelloApplication.class, args);
  &#125;
</code></pre>
</li>
</ul>
<p>}</p>
<pre><code class="highlight plaintext">
**简单分析一下 SpringApplication 这个类 和它的 run 方法。**

- **SpringApplication主要用于**

    - 启动spring 应用的上下文
    - 配置应用的环境
    - 自动化装配 Spring 配置和组件。
    - 启动嵌入式的 Web 服务器 （如果是Web应用）。
    - 执行Spring Boot 特定的初始化操作。

- **SpringApplication.run() 方法**

  启动SpringBoot 应用常用的方式是通过 springApplication.run（）方法。它通常是在main（）方法中调用：
</code></pre>
<p>  public static void main(String[] args) {<br>      SpringApplication.run(Application.class, args);<br>  }<br>  <pre><code class="highlight plaintext">
  这个方法的作用是：

    - 启动Spring 应用上下文（ApplicationContext）。
    - 执行SpringBoot 的自动装配过程。
    - 启动内嵌的Web 服务器 (如果是web应用)

- **SpringApplication.run（） 的工作流程**

1. **创建 SpringApplication 实例：**

   创建一个 springApplication 实例，该实例会根据给定的启动类初始化应用。

2. **准备环境：**

   在初始化Spring 容器之前，SpringApplication 会准备好相应的环境(Environment),包括命令行参数，系统属性，配置文件（application.properties 或 application.yml）等。

3. **创建`ApplicationContext`：**

   根据配置，`SpringApplication` 会决定使用哪种类型的 `ApplicationContext`。默认情况下，如果是Web应用，会使用`AnnotationConfigServletWebApplicationContext`。如果是非 Web 应用，则使用 `AnnotationConfigApplicationContext`。

4. **初始化上下文(prepareContext):**

   在 `ApplicationContext` 被创建之后，`SpringApplication` 会对其进行初始化，加载 Spring 配置、自动配置类以及应用所需的所有 Bean。

5. **启动 `CommandLineRunner` 和 `ApplicationRunner`**：

   ​	`SpringApplication` 会扫描 `CommandLineRunner` 和 `ApplicationRunner` 接口的实现，并在应用启动时执行它们的 `run` 方法。这对于执行一些启动时需要的逻辑（如初始化数据）非常有用。

6. **启动嵌入式 Web 服务器（如果是 Web 应用）**：

   如果你的应用是一个 Web 应用，Spring Boot 会自动启动一个嵌入式的 Web 服务器（如 Tomcat、Jetty 或 Undertow）。如果没有配置为 Web 应用，Spring Boot 就不会启动 Web 服务器。

7. **应用启动完成**：

   最后，`SpringApplication` 会完成所有初始化工作并启动应用。应用启动后，Spring 容器开始正常工作，处理请求等。



### 五，Springboot配置

#### 	1，ymal语法

​		特别注意空格的配置，有层级关系。
</code></pre><br>person<br>    name: 秦疆<br>    age: 18</p>
<p>统一格式为:<br>实体类:<br>    属性名:空格 属性值<br>注意：这里的空格是不可少的，不然会报错。</p>
<pre><code class="highlight plaintext">
配置类要和配置文件绑定加 @ConfigurationProperties 注解



#### **2，JSR303校验**

JSR303（Java Specification Request 303）是 Java 的一个规范，定义了一组注解（Annotations）来验证 Java Bean 对象的属性是否符合特定的规则。这个规范为 Java 提供了标准的 Bean 验证方式，通常用于输入数据验证（如表单输入验证、API 请求体的验证等）。

常见的 JSR 303 注解有：

1. **@NotNull**：字段不能为空。
2. **@Size**：限制字符串、集合、数组等的大小。
3. **@Min** 和 **@Max**：限制数字的最小值和最大值。
4. **@Pattern**：正则表达式验证字符串格式。
5. **@Email**：验证电子邮件地址格式。
6. **@DecimalMin** 和 **@DecimalMax**：限制十进制数字的范围。
7. **@Future** 和 **@Past**：验证日期时间是否是将来或过去。
8. **@AssertTrue** 和 **@AssertFalse**：验证布尔值是否为真或假。
9. **@NotBlank**：验证字符串不能为空白字符。

使用这些注解时，通常需要配合一个验证框架来进行验证。最常用的实现是 **Hibernate Validator**，它是 JSR 303 的参考实现，也支持 JSR 380（Bean Validation 2.0）。



#### 3，SpringBoot多环境配置

在 Spring Boot 中，多环境配置可以通过使用 **profiles** 来实现，不同的环境配置可以通过不同的 **application-&#123;profile&#125;.properties** 或 **application-&#123;profile&#125;.yml** 文件来定义。常见的环境有开发环境、测试环境和生产环境等。

1），**使用 `application.properties` 或 `application.yml`**

Spring Boot 通过 `application.properties` 或 `application.yml` 文件来配置应用。为了支持多环境配置，我们可以在这些文件中根据不同的 profile 定义不同的配置。

a. **配置不同环境的配置文件**

例如：

- `application.properties`：默认配置，通常是通用配置
- `application-dev.properties`：开发环境的配置
- `application-prod.properties`：生产环境的配置

b. **配置多个环境的配置文件示例**

**`application.properties`**（默认配置）
</code></pre>
<p>spring.datasource.url&#x3D;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;default_db<br>server.port&#x3D;8080</p>
<pre><code class="highlight plaintext">
**`application-dev.properties`**（开发环境配置）
</code></pre>
<p>spring.datasource.url&#x3D;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;dev_db<br>server.port&#x3D;8081</p>
<pre><code class="highlight plaintext">
**`application-prod.properties`**（生产环境配置）
</code></pre>
<p>spring.datasource.url&#x3D;jdbc:mysql:&#x2F;&#x2F;prod-db-server:3306&#x2F;prod_db<br>server.port&#x3D;8080</p>
<pre><code class="highlight plaintext">
推荐使用ymal语法配置，

使用分隔符的方式配置多个端口，实例如下。
</code></pre>
<h1 id="默认配置"><a href="#默认配置" class="headerlink" title="默认配置"></a>默认配置</h1><p>server:<br>  port: 8081<br>spring:<br>  profiles:<br>    active: dev</p>
<hr>
<h1 id="开发环境的配置"><a href="#开发环境的配置" class="headerlink" title="开发环境的配置"></a>开发环境的配置</h1><p>server:<br>  port: 8082<br>spring:<br>  profiles:<br>    active: dev</p>
<hr>
<h1 id="测试环境的配置"><a href="#测试环境的配置" class="headerlink" title="测试环境的配置"></a>测试环境的配置</h1><p>server:<br>  port: 8083<br>spring:<br>  profiles:<br>    active: test</p>
<pre><code class="highlight plaintext">


### 六，Spring Web 开发

jar： webapp！

自动装配

springboot 到底帮我们呢配置了什么？我们能不能进行修改？能修改那些东西？能不能扩展？

- xxxAutoConfiguration...向容器中自动装配组件

- xxxProperties:自动装配类，装配配置文件中自定义的一些内容！

要解决的问题：

- 导入静态资源...
- 首页
- jsp，模板引擎下载 Thymeleaf
- 装配扩展 springMVC
- 增删改查
- 拦截器
- 国际化！



#### 1，静态资源的导入：

在 Spring Boot 中，静态资源的导入很简单，Spring Boot 会自动识别并提供访问静态资源的能力。静态资源通常包括 HTML、CSS、JavaScript 文件、图片等，它们一般放在 `src/main/resources/static` 或 `src/main/resources/public` 目录中。

**1）. 静态资源放置目录**

- **`src/main/resources/static`**：这是 Spring Boot 默认的静态资源目录，任何放在这个目录下的文件都可以通过 `/` 路径访问。
- **`src/main/resources/public`**：同样，Spring Boot 也会自动识别此目录并将其中的静态资源暴露出来。
- **`src/main/resources/resources`**：如果你放在这个目录下，Spring Boot 不会默认处理这些静态资源，需要通过额外的配置来指定访问路径。
- **`src/main/resources/META-INF/resources`**：Spring Boot 也会识别此目录。

**2）. 访问静态资源**

假设你将静态资源放在 `src/main/resources/static` 目录下，如下结构：
</code></pre>
<p>src&#x2F;<br> └── main&#x2F;<br>      └── resources&#x2F;<br>           └── static&#x2F;<br>                ├── css&#x2F;<br>                │    └── style.css<br>                ├── js&#x2F;<br>                │    └── script.js<br>                └── images&#x2F;<br>                     └── logo.png</p>
<pre><code class="highlight plaintext">
那么，你可以通过以下 URL 访问这些资源：

- **CSS**：`http://localhost:8080/css/style.css`
- **JavaScript**：`http://localhost:8080/js/script.js`
- **图片**：`http://localhost:8080/images/logo.png`

**3）， 配置 Spring Boot 托管静态资源（可选）**

虽然 Spring Boot 默认会处理 `static` 和 `public` 目录中的静态资源，但如果需要自定义静态资源路径，可以通过配置来指定。例如，修改 `application.properties` 文件来更改默认路径：
</code></pre>
<h1 id="设置静态资源路径"><a href="#设置静态资源路径" class="headerlink" title="设置静态资源路径"></a>设置静态资源路径</h1><p>spring.resources.static-locations&#x3D;classpath:&#x2F;my-static&#x2F;</p>
<pre><code class="highlight plaintext">
这样，Spring Boot 将从 `src/main/resources/my-static` 目录中加载静态资源，而不是默认的 `static` 目录。

**4. 启用 WebMvcConfigurer 来定制静态资源**

如果你需要进一步定制静态资源的访问路径或行为，可以实现 `WebMvcConfigurer` 接口并重写 `addResourceHandlers` 方法。
</code></pre>
<p>import org.springframework.context.annotation.Configuration;<br>import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;<br>import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;</p>
<p>@Configuration<br>public class WebConfig implements WebMvcConfigurer {</p>
<pre><code>@Override
public void addResourceHandlers(ResourceHandlerRegistry registry) &#123;
    // 映射静态资源路径
    registry.addResourceHandler(&quot;/assets/**&quot;)
            .addResourceLocations(&quot;classpath:/static/assets/&quot;);
&#125;
</code></pre>
<p>}</p>
<pre><code class="highlight plaintext">
在这个例子中，静态资源目录 `src/main/resources/static/assets` 将会映射到 `http://localhost:8080/assets/` 路径下。

**5. 其他注意事项**

- 静态资源的访问是通过路径 `/static/` 公开的，但可以在 `application.properties` 或 `application.yml` 文件中通过配置更改路径。
- 静态资源通常不需要特别的控制器来处理，Spring Boot 会自动处理。
- 你也可以将静态文件打包到 JAR 或 WAR 中，Spring Boot 会自动解析并提供静态文件服务。



#### 2，首页和图标

**1），首页**

你可以通过控制器映射自定义 `/` 路径，返回 HTML 页面或简单的文本。

**2），图标**

将 `favicon.ico` 文件放在 `src/main/resources/static` 目录下，Spring Boot 会自动识别并暴露它。你还可以在 HTML 中通过 `&lt;link&gt;` 标签来定义 favicon。



#### **3，thymeleaf模版引擎**

结论：只要需要使用 thymleaf 模板引擎，只要导入对应的依赖就可以了，我们将 html 页面放在templates目录下即可。
</code></pre>
<dependencies>
    <!-- Spring Boot Web Starter -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>

<pre><code>&lt;!-- Spring Boot Thymeleaf Starter --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;
&lt;/dependency&gt;

&lt;!-- 其他可能需要的依赖 --&gt;

&lt;dependency&gt;
      &lt;groupId&gt;org.thymeleaf&lt;/groupId&gt;
      &lt;artifactId&gt;thymeleaf&lt;/artifactId&gt;
      &lt;version&gt;3.1.3.RELEASE&lt;/version&gt;
  &lt;/dependency&gt;
</code></pre>
</dependencies>
<pre><code class="highlight plaintext">
1&gt;，thymleaf 官网：[https://www.thymeleaf.org/](https://www.thymeleaf.org/)

2&gt;，thymleaf 在Github 的主页 ：[https://github.com/thymeleaf/thymeleaf](https://github.com/thymeleaf/thymeleaf)



#### 4，装配扩展springMVC

**1，springboot 扩展视图解析器：**

**`ViewResolver` 自定义配置**

你可以创建一个 `@Configuration` 类来进一步自定义视图解析器：
</code></pre>
package com.example.demo.config;

<p>import org.springframework.context.annotation.Bean;<br>import org.springframework.context.annotation.Configuration;<br>import org.springframework.web.servlet.view.InternalResourceViewResolver;<br>import org.springframework.web.servlet.view.UrlBasedViewResolver;<br>import org.springframework.web.servlet.ViewResolver;<br>import org.springframework.web.servlet.view.freemarker.FreeMarkerViewResolver;<br>import org.springframework.web.servlet.view.thymeleaf.ThymeleafViewResolver;</p>
<p>@Configuration<br>public class ViewResolverConfig {</p>
<pre><code>// 配置 Thymeleaf 视图解析器
@Bean
public ViewResolver thymeleafViewResolver(org.thymeleaf.spring6.SpringTemplateEngine templateEngine) &#123;
    ThymeleafViewResolver resolver = new ThymeleafViewResolver();
    resolver.setTemplateEngine(templateEngine);
    resolver.setOrder(1);  // 设置解析顺序，优先级越高越先解析
    resolver.setCharacterEncoding(&quot;UTF-8&quot;);
    return resolver;
&#125;

// 配置 FreeMarker 视图解析器
@Bean
public FreeMarkerViewResolver freeMarkerViewResolver() &#123;
    FreeMarkerViewResolver resolver = new FreeMarkerViewResolver();
    resolver.setPrefix(&quot;/WEB-INF/views/&quot;);
    resolver.setSuffix(&quot;.ftl&quot;);
    resolver.setCache(true);
    resolver.setOrder(2);
    return resolver;
&#125;

// 配置 JSP 视图解析器
@Bean
public InternalResourceViewResolver internalResourceViewResolver() &#123;
    InternalResourceViewResolver resolver = new InternalResourceViewResolver();
    resolver.setPrefix(&quot;/WEB-INF/jsp/&quot;);
    resolver.setSuffix(&quot;.jsp&quot;);
    resolver.setOrder(3);
    return resolver;
&#125;
</code></pre>
<p>}</p>
<pre><code class="highlight plaintext">


### 七，简单聊一下如何快速的搭建一个网站

​	#1、前端的设计：页面张什么样子：该怎么给数据

​	#2、设计数据库	(数据库设计难点。)

​	#3、前端让他能够自己独立运行，独立化工程。

​	#4、数据接口如何对接：JSON 对象 all in one！

​	#5、前后端联调测试！

1，有一套自己熟悉的后台模板：工作必要！例如 x-admin

2，前端页面：至少自己能通过前端框架，组合出来一个网站页面。一个简单的网站页面至少需要以下几部分构成。

​	-index

​	-about

​	-blog

​	-post

​	-user

3，让这个网站能独立运行！



### 八，Springboot 整合jdbc使用

Spring Boot 中整合 JDBC 相对简单，Spring Boot 提供了对JDBC的良好支持。

**1，添加依赖**

确保你的 pom.xml 文件中添加了和数据库相关的依赖。示例如下：
</code></pre>
 <dependency>
         <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-jdbc</artifactId>
 </dependency>
<pre><code class="highlight plaintext">
**2，配置数据源**

在 application.properties 或者 application.yml 中配置数据库连接。示例如下
</code></pre>
spring:
  datasource:
    username: root
    password: 123456
    #?serverTimezone=UTC 解决时区的报错时需要加的错误
    url: jdbc:mysql://localhost:3306/mybatis?								       
    serverTimezone=UTC&useUnicode=true&characterEncoding=utf-8
    driver-class-name: com.mysql.cj.jdbc.Driver
    type: com.alibaba.druid.pool.DruidDataSource
    #自定义数据源
      
     
<pre><code class="highlight plaintext">
**3，创建JdbcTemplate**

Spring Boot 已经为你配置好了 JdbcTemplate，你可以在你的sevice类中注入并使用它。JdbcTemplate 是Spring 提供的用于操作数据库的核心类，能够简化JDBC的操作。
</code></pre>
<p>import org.springframework.beans.factory.annotation.Autowired;<br>import org.springframework.jdbc.core.JdbcTemplate;<br>import org.springframework.stereotype.Service;</p>
<p>@Service<br>public class UserService {</p>
<pre><code>@Autowired
private JdbcTemplate jdbcTemplate;

public void insertUser(String username, String password) &#123;
    String sql = &quot;INSERT INTO users (username, password) VALUES (?, ?)&quot;;
    jdbcTemplate.update(sql, username, password);
&#125;

public List&lt;User&gt; getAllUsers() &#123;
    String sql = &quot;SELECT * FROM users&quot;;
    return jdbcTemplate.query(sql, (rs, rowNum) -&gt; &#123;
        User user = new User();
        user.setId(rs.getLong(&quot;id&quot;));
        user.setUsername(rs.getString(&quot;username&quot;));
        user.setPassword(rs.getString(&quot;password&quot;));
        return user;
    &#125;);
&#125;
</code></pre>
<p>}</p>
<pre><code class="highlight plaintext">
**4，创建User 实体类**

你可以根据数据库中的表结构，创建对应的实体类 User。
</code></pre>
<p>public class User {<br>    private Long id;<br>    private String username;<br>    private String password;</p>
<pre><code>// Getters and Setters
</code></pre>
<p>}</p>
<pre><code class="highlight plaintext">
**5,使用 Service 进行操作**

最后，你可以在controller 中调用 Service 进行数据库操作。
</code></pre>
<p>import org.springframework.beans.factory.annotation.Autowired;<br>import org.springframework.web.bind.annotation.*;</p>
<p>import java.util.List;</p>
<p>@RestController<br>@RequestMapping(“&#x2F;users”)<br>public class UserController {</p>
<pre><code>@Autowired
private UserService userService;

@PostMapping
public String createUser(@RequestParam String username, @RequestParam String password) &#123;
    userService.insertUser(username, password);
    return &quot;User created successfully!&quot;;
&#125;

@GetMapping
public List&lt;User&gt; getAllUsers() &#123;
    return userService.getAllUsers();
&#125;
</code></pre>
<p>}</p>
<pre><code class="highlight plaintext">
6，启动项目

确保数据库已经出创建并且可以连接spring boot 应用程序，运行Spring Boot 项目后，应该可以通过/Users 路径进行基本的用户操作。



九，整合Druid数据源

Druid 数据源是一个性能高，功能强大的数据数据库连接池，常用来处理数据库丽娜姐的管理。以下是Springboot如何整合Druid数据源的步骤。

1、添加依赖

首先，你需要在 pom.xml 中添加相关的依赖。
</code></pre>
<!-- Druid 数据源 -->
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
    &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;
    &lt;version&gt;1.1.22&lt;/version&gt; &lt;!-- 版本可以根据需要调整 --&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code class="highlight plaintext">
2、配置Druid 数据源

在 application.properties 或 application.yml 中配置Druid 数据源。以下是 application.properties 的示例配置：
</code></pre>
<h1 id="配置-Druid-数据源"><a href="#配置-Druid-数据源" class="headerlink" title="配置 Druid 数据源"></a>配置 Druid 数据源</h1><p>spring.datasource.druid.url&#x3D;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;your_database?useSSL&#x3D;false&amp;serverTimezone&#x3D;UTC<br>spring.datasource.druid.username&#x3D;root<br>spring.datasource.druid.password&#x3D;yourpassword<br>spring.datasource.druid.driver-class-name&#x3D;com.mysql.cj.jdbc.Driver</p>
<h1 id="Druid-配置"><a href="#Druid-配置" class="headerlink" title="Druid 配置"></a>Druid 配置</h1><p>spring.datasource.druid.initial-size&#x3D;5<br>spring.datasource.druid.min-idle&#x3D;5<br>spring.datasource.druid.max-active&#x3D;20<br>spring.datasource.druid.max-wait&#x3D;60000<br>spring.datasource.druid.validation-query&#x3D;SELECT 1 FROM DUAL<br>spring.datasource.druid.test-on-borrow&#x3D;true<br>spring.datasource.druid.test-while-idle&#x3D;true<br>spring.datasource.druid.time-between-eviction-runs-millis&#x3D;60000<br>spring.datasource.druid.min-evictable-idle-time-millis&#x3D;300000<br>spring.datasource.druid.pool-prepared-statements&#x3D;true<br>spring.datasource.druid.max-open-prepared-statements&#x3D;20</p>
<pre><code class="highlight plaintext">
3、配置Druid 数据源Bean

spring Boot 的druid-spring-boot-starter 会自动配置Druid 数据源，但你可以过呢据手动配置跟多细节，或者扩展，例如在你的`@Configuration` 类中，配置 Druid 数据源：如下
</code></pre>
<p>import com.alibaba.druid.pool.DruidDataSource;<br>import org.springframework.beans.factory.annotation.Value;<br>import org.springframework.context.annotation.Bean;<br>import org.springframework.context.annotation.Configuration;<br>import javax.sql.DataSource;</p>
<p>@Configuration<br>public class DruidDataSourceConfig {</p>
<pre><code>@Value(&quot;$&#123;spring.datasource.druid.url&#125;&quot;)
private String url;

@Value(&quot;$&#123;spring.datasource.druid.username&#125;&quot;)
private String username;

@Value(&quot;$&#123;spring.datasource.druid.password&#125;&quot;)
private String password;

@Value(&quot;$&#123;spring.datasource.druid.driver-class-name&#125;&quot;)
private String driverClassName;

@Value(&quot;$&#123;spring.datasource.druid.initial-size&#125;&quot;)
private int initialSize;

@Value(&quot;$&#123;spring.datasource.druid.min-idle&#125;&quot;)
private int minIdle;

@Value(&quot;$&#123;spring.datasource.druid.max-active&#125;&quot;)
private int maxActive;

@Value(&quot;$&#123;spring.datasource.druid.max-wait&#125;&quot;)
private long maxWait;

@Value(&quot;$&#123;spring.datasource.druid.validation-query&#125;&quot;)
private String validationQuery;

@Bean
public DataSource dataSource() &#123;
    DruidDataSource dataSource = new DruidDataSource();
    dataSource.setUrl(url);
    dataSource.setUsername(username);
    dataSource.setPassword(password);
    dataSource.setDriverClassName(driverClassName);
    dataSource.setInitialSize(initialSize);
    dataSource.setMinIdle(minIdle);
    dataSource.setMaxActive(maxActive);
    dataSource.setMaxWait(maxWait);
    dataSource.setValidationQuery(validationQuery);
    return dataSource;
&#125;
</code></pre>
<p>}</p>
<pre><code class="highlight plaintext">


### 九，springboot 整合 mybatis 框架

在sping boot 中整合mybatis 框架，可以实现数据库访问层。轻松的实现数据库操作。

#### 1、创建 springboot 项目，选择以下依赖。

- Spring Web
- MyBatis Framework
- MySQL Driver（如果你使用的是 MySQL 数据库）

或者如果你是使用 Maven 构建，可以手动添加相关依赖。

#### 2. 添加依赖

在 `pom.xml` 文件中，加入如下依赖：
</code></pre>
<dependencies>
    <!-- Spring Boot Starter Web -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>

<pre><code>&lt;!-- MyBatis Spring Boot Starter --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;
    &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;
    &lt;version&gt;2.2.0&lt;/version&gt; &lt;!-- 根据实际情况选择版本 --&gt;
&lt;/dependency&gt;

&lt;!-- MySQL JDBC Driver --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;mysql&lt;/groupId&gt;
    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
&lt;/dependency&gt;

&lt;!-- Spring Boot Starter Data JPA (Optional) --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;
&lt;/dependency&gt;

&lt;!-- Spring Boot Starter Test (Optional for testing) --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>
</dependencies>
<pre><code class="highlight plaintext">
#### 3、配置数据源和MyBatis

在 `application.properties` 或 `application.yml` 中配置数据库连接：
</code></pre>
spring.datasource.url=jdbc:mysql://localhost:3306/your_database_name?useUnicode=true&characterEncoding=UTF-8&serverTimezone=UTC
spring.datasource.username=root
spring.datasource.password=root
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver

<h1 id="MyBatis配置"><a href="#MyBatis配置" class="headerlink" title="MyBatis配置"></a>MyBatis配置</h1><p>mybatis.mapper-locations&#x3D;classpath:&#x2F;mappers&#x2F;*.xml<br>mybatis.type-aliases-package&#x3D;com.example.demo.model</p>
<pre><code class="highlight plaintext">
- `mybatis.mapper-locations`：指定 MyBatis 映射文件的位置。

- `mybatis.type-aliases-package`：指定 MyBatis 映射对象的包位

#### 4、创建 Model 类（实体类）
</code></pre>
<p>package com.example.demo.model;</p>
<p>public class User {<br>    private int id;<br>    private String name;<br>    private int age;</p>
<pre><code>// getters and setters
</code></pre>
<p>}</p>
<pre><code class="highlight plaintext">
#### 5、创建 Mapper 接口

MyBatis 使用接口来定义数据库操作：
</code></pre>
<p>package com.example.demo.mapper;</p>
<p>import com.example.demo.model.User;<br>import org.apache.ibatis.annotations.Mapper;<br>import java.util.List;</p>
<p>@Mapper<br>public interface UserMapper {<br>    List<User> findAll();<br>    User findById(int id);<br>    void insertUser(User user);<br>}</p>
<pre><code class="highlight plaintext">
使用 `@Mapper` 注解标记该接口是一个 MyBatis 映射器。

#### 6、创建 Mapper XML 文件（可选）

你可以使用 XML 文件来定义 SQL 语句（也可以使用注解代替）：
</code></pre>
<!-- resources/mappers/UserMapper.xml -->
<mapper namespace="com.example.demo.mapper.UserMapper">

<pre><code>&lt;select id=&quot;findAll&quot; resultType=&quot;com.example.demo.model.User&quot;&gt;
    SELECT * FROM users;
&lt;/select&gt;

&lt;select id=&quot;findById&quot; parameterType=&quot;int&quot; resultType=&quot;com.example.demo.model.User&quot;&gt;
    SELECT * FROM users WHERE id = #&#123;id&#125;;
&lt;/select&gt;

&lt;insert id=&quot;insertUser&quot; parameterType=&quot;com.example.demo.model.User&quot;&gt;
    INSERT INTO users (name, age) VALUES (#&#123;name&#125;, #&#123;age&#125;);
&lt;/insert&gt;
</code></pre>
</mapper>
<pre><code class="highlight plaintext">
#### 7. 服务层调用 Mapper

在业务层，你可以通过注入 `UserMapper` 接口来调用数据库操作：
</code></pre>
package com.example.demo.service;

<p>import com.example.demo.mapper.UserMapper;<br>import com.example.demo.model.User;<br>import org.springframework.beans.factory.annotation.Autowired;<br>import org.springframework.stereotype.Service;<br>import java.util.List;</p>
<p>@Service<br>public class UserService {</p>
<pre><code>@Autowired
private UserMapper userMapper;

public List&lt;User&gt; getAllUsers() &#123;
    return userMapper.findAll();
&#125;

public User getUserById(int id) &#123;
    return userMapper.findById(id);
&#125;

public void createUser(User user) &#123;
    userMapper.insertUser(user);
&#125;
</code></pre>
<p>}</p>
<pre><code class="highlight plaintext">
#### 8.、使用控制器

最后，你可以通过 Spring MVC 创建一个控制器来访问这些服务：
</code></pre>
<p>package com.example.demo.controller;</p>
<p>import com.example.demo.model.User;<br>import com.example.demo.service.UserService;<br>import org.springframework.beans.factory.annotation.Autowired;<br>import org.springframework.web.bind.annotation.*;</p>
<p>import java.util.List;</p>
<p>@RestController<br>@RequestMapping(“&#x2F;users”)<br>public class UserController {</p>
<pre><code>@Autowired
private UserService userService;

@GetMapping
public List&lt;User&gt; getAllUsers() &#123;
    return userService.getAllUsers();
&#125;

@GetMapping(&quot;/&#123;id&#125;&quot;)
public User getUserById(@PathVariable int id) &#123;
    return userService.getUserById(id);
&#125;

@PostMapping
public void createUser(@RequestBody User user) &#123;
    userService.createUser(user);
&#125;
</code></pre>
<p>}</p>
<pre><code class="highlight plaintext">
#### 9. 运行应用

启动 Spring Boot 应用程序，你可以通过浏览器或者 Postman 访问接口，验证 MyBatis 与 Spring Boot 的集成是否成功。



### 十、spring security 环境搭建

spring security 可以帮助你实现应用的身份认证和授权。spring security 是一个安全框架，提供身份验证，访问控制和攻击防护等功能。搭建步骤如下：

#### 1、创建 spring boot 项目，

首先，使用 [Spring Initializr](https://start.spring.io/) 创建一个 Spring Boot 项目，并选择以下依赖：

- Spring Web
- Spring Security

如果你使用的是 Maven，可以在 `pom.xml` 中手动添加如下依赖：
</code></pre>
<dependencies>
    <!-- Spring Boot Starter Web -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>

<pre><code>&lt;!-- Spring Security --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;
&lt;/dependency&gt;

&lt;!-- Spring Boot Starter Thymeleaf (如果需要模板引擎) --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;
&lt;/dependency&gt;

&lt;!-- Spring Boot Starter Data JPA (如果需要数据库支持) --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;
&lt;/dependency&gt;

&lt;!-- H2 Database (可选，仅用于测试) --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.h2database&lt;/groupId&gt;
    &lt;artifactId&gt;h2&lt;/artifactId&gt;
    &lt;scope&gt;runtime&lt;/scope&gt;
&lt;/dependency&gt;

&lt;!-- Spring Boot Starter Test --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>
</dependencies>
<pre><code class="highlight plaintext">
#### 2. 配置 Spring Security

Spring Security 默认会为你的应用提供基础的安全保护，如基于 HTTP 的认证（表单登录）和简单的权限管理。

在 `application.properties` 或 `application.yml` 中，你可以配置一些基本的设置，比如自定义登录页面、用户名和密码等。
</code></pre>
# 自定义登录页面
spring.security.user.name=user
spring.security.user.password=password
<pre><code class="highlight plaintext">
#### 3. 配置 SecurityConfig 类

你可以创建一个配置类来定制 Spring Security 的行为，允许你控制身份验证方式、授权规则等。
</code></pre>
package com.example.demo.config;

<p>import org.springframework.context.annotation.Bean;<br>import org.springframework.context.annotation.Configuration;<br>import org.springframework.security.config.annotation.web.builders.HttpSecurity;<br>import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;<br>import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;</p>
<p>@Configuration<br>@EnableWebSecurity<br>public class SecurityConfig extends WebSecurityConfigurerAdapter {</p>
<pre><code>@Override
protected void configure(HttpSecurity http) throws Exception &#123;
    // 定制安全策略
    http
        .authorizeRequests()
            .antMatchers(&quot;/&quot;, &quot;/home&quot;).permitAll()  // 允许访问根目录和/home
            .anyRequest().authenticated()          // 其他请求需要认证
        .and()
        .formLogin()
            .loginPage(&quot;/login&quot;)                   // 自定义登录页面
            .permitAll()
        .and()
        .logout()
            .permitAll();
&#125;
</code></pre>
<p>}</p>
<pre><code class="highlight plaintext">
#### 4. 创建登录页面（可选）

如果你想自定义登录页面，可以创建一个 `login.html` 文件，例如使用 Thymeleaf 模板引擎来生成页面。
</code></pre>
<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <title>Login</title>
</head>
<body>
    <h1>Please log in</h1>
    <form action="#" th:action="@{/login}" method="post">
        <label for="username">Username:</label>
        <input type="text" id="username" name="username" /><br />
        
<pre><code>    &lt;label for=&quot;password&quot;&gt;Password:&lt;/label&gt;
    &lt;input type=&quot;password&quot; id=&quot;password&quot; name=&quot;password&quot; /&gt;&lt;br /&gt;
    
    &lt;button type=&quot;submit&quot;&gt;Login&lt;/button&gt;
&lt;/form&gt;
</code></pre>
</body>
</html>
<pre><code class="highlight plaintext">
#### 5. 创建控制器

创建一个控制器来处理登录后的请求或未认证的请求。
</code></pre>
package com.example.demo.controller;

<p>import org.springframework.stereotype.Controller;<br>import org.springframework.web.bind.annotation.GetMapping;</p>
<p>@Controller<br>public class HomeController {</p>
<pre><code>@GetMapping(&quot;/&quot;)
public String home() &#123;
    return &quot;home&quot;;  // 返回主页
&#125;

@GetMapping(&quot;/login&quot;)
public String login() &#123;
    return &quot;login&quot;;  // 返回登录页面
&#125;

@GetMapping(&quot;/admin&quot;)
public String admin() &#123;
    return &quot;admin&quot;;  // 需要权限才能访问的页面
&#125;
</code></pre>
<p>}</p>
<pre><code class="highlight plaintext">
#### 6. 配置用户存储（内存用户）

如果你希望使用内存中的用户进行认证（适合开发和测试），可以在 `SecurityConfig` 中配置用户存储：
</code></pre>
<p>import org.springframework.security.config.annotation.web.builders.HttpSecurity;<br>import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;<br>import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;</p>
<p>@Configuration<br>@EnableWebSecurity<br>public class SecurityConfig extends WebSecurityConfigurerAdapter {</p>
<pre><code>@Override
protected void configure(HttpSecurity http) throws Exception &#123;
    http
        .authorizeRequests()
            .antMatchers(&quot;/&quot;, &quot;/home&quot;).permitAll()
            .anyRequest().authenticated()
        .and()
        .formLogin()
            .permitAll()
        .and()
        .logout()
            .permitAll();
&#125;

@Override
protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123;
    auth.inMemoryAuthentication()
        .withUser(&quot;user&quot;).password(&quot;&#123;noop&#125;password&quot;).roles(&quot;USER&quot;)
        .and()
        .withUser(&quot;admin&quot;).password(&quot;&#123;noop&#125;admin&quot;).roles(&quot;ADMIN&quot;);
&#125;
</code></pre>
<p>}</p>
<pre><code class="highlight plaintext">
#### 7. 使用数据库存储用户（可选）

如果需要使用数据库存储用户信息，可以配置 `JdbcUserDetailsManager` 或 `UserDetailsService` 来连接数据库，并自定义认证过程。
</code></pre>
<p>import org.springframework.security.config.annotation.web.builders.HttpSecurity;<br>import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;<br>import org.springframework.security.core.userdetails.User;<br>import org.springframework.security.core.userdetails.UserDetailsService;<br>import org.springframework.context.annotation.Bean;<br>import org.springframework.security.core.userdetails.jdbc.JdbcDaoImpl;</p>
<p>@Configuration<br>@EnableWebSecurity<br>public class SecurityConfig extends WebSecurityConfigurerAdapter {</p>
<pre><code>@Override
protected void configure(HttpSecurity http) throws Exception &#123;
    http
        .authorizeRequests()
            .antMatchers(&quot;/&quot;).permitAll()
            .anyRequest().authenticated()
        .and()
        .formLogin()
            .permitAll()
        .and()
        .logout()
            .permitAll();
&#125;

@Override
protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123;
    auth.userDetailsService(userDetailsService());
&#125;

@Bean
public UserDetailsService userDetailsService() &#123;
    JdbcDaoImpl jdbcDao = new JdbcDaoImpl();
    jdbcDao.setDataSource(dataSource);  // 配置数据源
    return jdbcDao;
&#125;
</code></pre>
<p>}</p>
<pre><code class="highlight plaintext">
#### 8. 启动应用

启动应用程序后，你可以访问应用的 URL，例如 `http://localhost:8080/`，默认会要求你登录。如果使用内存认证用户，则可以尝试使用 `user/password` 或 `admin/admin` 登录。



### 十一，shiro

Shiro 是一个功能强大的 Java 安全框架，主要用于提供认证、授权、加密、会话管理等安全服务。它使得开发者可以轻松地对 Java 应用程序进行访问控制、身份验证等操作。Shiro 的设计简单且灵活，可以非常方便地集成到各种 Java 应用中，尤其适合需要高度安全性的 web 和企业应用。

#### 主要功能：

1. **认证(Authentication)：**验证用户身份，通常通过用户名和密码。
2. **授权(Authorization)**：控制用户对特定资源的访问权限，例如角色和权限管理。
3. **会话管理(Session Management)：**管理用户会话，在无状态的 Web 环境中保持用户状态。
4. **加密(Cryptography)**:提供密码和数据加密等安全功能。
5. **Web 支持**: 提供了 Web 环境下的特定支持，能简化 Web 安全控制。

#### **使用shiro 的基本步骤**

**1、添加依赖**

如果使用Maven，就可以添加以下依赖：
</code></pre>
<dependency>
    <groupId>org.apache.shiro</groupId>
    <artifactId>shiro-core</artifactId>
    <version>1.10.1</version> <!-- 请检查最新版本 -->
</dependency>
<pre><code class="highlight plaintext">
**2、配置 SecurityManager**

在 Shiro 中，Security 是中心组件，负责管理安全操作。通常你需要创建一个 SecurityManager 配置类。
</code></pre>
@Configuration
public class ShiroConfig {

<pre><code>@Bean
public SecurityManager securityManager() &#123;
    DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager();
    securityManager.setRealm(myRealm());  // 设置自定义 Realm
    return securityManager;
&#125;

@Bean
public Realm myRealm() &#123;
    MyCustomRealm realm = new MyCustomRealm();
    return realm;
&#125;
</code></pre>
<p>}</p>
<pre><code class="highlight plaintext">
**3、创建自定义 Realm**

Shiro 通过 `Realm` 来完成身份验证和授权。你可以继承 `AuthorizingRealm` 来创建自定义的 Realm。
</code></pre>
<p>public class MyCustomRealm extends AuthorizingRealm {<br>    @Override<br>    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) {<br>        &#x2F;&#x2F; 返回用户的权限和角色<br>        SimpleAuthorizationInfo info &#x3D; new SimpleAuthorizationInfo();<br>        info.addRole(“admin”);<br>        info.addStringPermission(“user:create”);<br>        return info;<br>    }</p>
<pre><code>@Override
protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException &#123;
    // 通过用户名密码进行身份验证
    String username = (String) token.getPrincipal();
    // 假设从数据库中查询用户密码
    String password = &quot;password123&quot;; // 假数据

    return new SimpleAuthenticationInfo(username, password, getName());
&#125;
</code></pre>
<p>}</p>
<pre><code class="highlight plaintext">
**4、登录与授权**

在 Shiro 中，登录通常通过 `Subject` 来进行，使用 `SecurityManager` 来管理。
</code></pre>
<p>Subject currentUser &#x3D; SecurityUtils.getSubject();<br>UsernamePasswordToken token &#x3D; new UsernamePasswordToken(“username”, “password”);</p>
<p>try {<br>    currentUser.login(token);<br>    &#x2F;&#x2F; 登录成功<br>} catch (AuthenticationException e) {<br>    &#x2F;&#x2F; 登录失败<br>}</p>
<pre><code class="highlight plaintext">
**5、配置Shiro filter**

在 Web 应用中，你通常会使用 `ShiroFilter` 来处理 URL 权限控制。可以在 `web.xml` 或者 Spring 配置类中配置。
</code></pre>
<filter>
    <filter-name>shiroFilter</filter-name>
    <filter-class>org.apache.shiro.web.filter.authc.FormAuthenticationFilter</filter-class>
</filter>
<pre><code class="highlight plaintext">
**6、使用 Shiro 标签**

如果你是在 JSP 页面中使用，可以通过 Shiro 标签来控制页面访问权限。
</code></pre>
<shiro:authenticating>
    <p>用户已经登录</p>
</shiro:authenticating>
<pre><code class="highlight plaintext">
**总结**

Shiro 提供了丰富的安全功能，但配置起来相对简单，适用于各种类型的 Java 应用。你可以根据需求定制自己的 Realm、认证和授权逻辑，也可以通过简单的配置和注解来快速集成安全功能。



### 十二、swagger 介绍及集成

**Swagger** 是一个用于生成、描述、调用和可视化 RESTful API 的工具集。它通过开放API规范（OpenAPI Specification, OAS）提供了一种标准的方式来描述API，允许开发者、测试人员和用户理解、使用和测试 API，而无需阅读大量文档。

Swagger 包括多个工具和库，如：

- **Swagger UI**：提供一个交互式的用户界面，用于浏览和测试 API。
- **Swagger Codegen**：用于生成服务器端和客户端代码。
- **Swagger Editor**：基于浏览器的工具，用于编辑 API 文档并生成 OpenAPI 规范。
- **Swagger UI**：可以在浏览器中查看并交互式地使用 API。
- **Swagger Annotations**：用于在 Java 代码中嵌入 API 的元数据。

#### Swagger 的优点：

1. **标准化 API 文档**：Swagger 提供了开放的标准（OpenAPI Specification），可以有效地描述 API。
2. **交互式文档**：通过 Swagger UI，开发人员和用户可以直接在浏览器中测试 API，减少了文档和代码之间的差距。
3. **代码生成**：Swagger Codegen 可以生成服务器端、客户端的代码，减少了重复的工作。
4. **易于集成**：Swagger 提供了多种语言和框架的支持，方便与现有的项目集成。

#### swagger 集成步骤

**1、添加依赖**
</code></pre>
<dependency>
    <groupId>io.springfox</groupId>
    <artifactId>springfox-swagger2</artifactId>
    <version>2.9.2</version> <!-- 可以根据实际需要更新版本 -->
</dependency>
<dependency>
    <groupId>io.springfox</groupId>
    <artifactId>springfox-swagger-ui</artifactId>
    <version>2.9.2</version> <!-- 可以根据实际需要更新版本 -->
</dependency>
<pre><code class="highlight plaintext">
**2、配置 Swagger**

在 Spring Boot 项目中配置 Swagger，可以创建一个配置类来启用 Swagger。
</code></pre>
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import springfox.documentation.builders.PathSelectors;
import springfox.documentation.builders.RequestHandlerSelectors;
import springfox.documentation.spi.DocumentationType;
import springfox.documentation.spring.web.plugins.Docket;

<p>@Configuration<br>public class SwaggerConfig {</p>
<pre><code>@Bean
public Docket api() &#123;
    return new Docket(DocumentationType.SWAGGER_2)
            .select()
            .apis(RequestHandlerSelectors.basePackage(&quot;com.example.controller&quot;)) // 指定扫描的包路径
            .paths(PathSelectors.any())  // 扫描所有的API接口
            .build();
&#125;
</code></pre>
<p>}</p>
<pre><code class="highlight plaintext">
- `RequestHandlerSelectors.basePackage(&quot;com.example.controller&quot;)`: 用于指定扫描控制器的包路径。

- `PathSelectors.any()`: 表示扫描所有的 API 路径。

**3、启用Swagger 注解**

在控制器类和方法中，可以使用Swagger 提供的注解来描述API，增强文档的可读性。常见的Swagger注解:

- `@Api`：用于描述类，通常用于控制器类。

- `@ApiOperation`：描述一个操作方法（API）。

- `@ApiParam`：描述方法参数。

- `@ApiResponse`：描述 API 的响应信息。
</code></pre>
<p>import io.swagger.annotations.Api;<br>import io.swagger.annotations.ApiOperation;<br>import io.swagger.annotations.ApiParam;<br>import org.springframework.web.bind.annotation.GetMapping;<br>import org.springframework.web.bind.annotation.RestController;</p>
<p>@Api(value &#x3D; “User Controller”, tags &#x3D; “用户管理相关API”)<br>@RestController<br>public class UserController {</p>
<pre><code>@ApiOperation(value = &quot;获取用户列表&quot;, notes = &quot;返回所有用户的详细信息&quot;)
@GetMapping(&quot;/users&quot;)
public List&lt;User&gt; getUsers() &#123;
    return userService.getAllUsers();
&#125;

@ApiOperation(value = &quot;根据ID获取用户&quot;, notes = &quot;根据用户ID查询用户&quot;)
@GetMapping(&quot;/users/&#123;id&#125;&quot;)
public User getUserById(@ApiParam(value = &quot;用户ID&quot;, required = true) @PathVariable Long id) &#123;
    return userService.getUserById(id);
&#125;
</code></pre>
<p>}</p>
<pre><code class="highlight plaintext">
**4、访问 Swagger UI**

启动 Spring Boot 应用后，Swagger UI 将默认部署在 `http://localhost:8080/swagger-ui.html` 路径下。在该页面上，可以查看 API 文档，并进行交互式的测试。



### 十三、springboot 集成 redis

在Spring boot 项目中集成Redis, 可以利用 Spring Data Redis 提供的功能，简化Redis 的操作。Spring Data Redis 是一个用于与 Redis 交互的框架，他提供了对 Redis 的自动配置i支持。

以下是Redis 集成到 Spring Boot 项目的步骤：

#### 1、添加 Redis 相关依赖

先，在 `pom.xml` 文件中添加 Spring Boot 和 Redis 相关的依赖。
</code></pre>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-redis</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-logging</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.data</groupId>
    <artifactId>spring-data-redis</artifactId>
    <version>2.8.0</version> <!-- 可以根据需要选择版本 -->
</dependency>
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-context</artifactId>
    <version>5.3.8</version> <!-- 如果需要，修改为合适的版本 -->
</dependency>
<pre><code class="highlight plaintext">
#### **2、配置Redis 连接**

在 `application.properties` 或 `application.yml` 中配置 Redis 的连接信息。

**使用** `application.properties` **配置：**
</code></pre>
spring.redis.host=localhost
spring.redis.port=6379
spring.redis.password=your_password  # 如果有密码的话
spring.redis.database=0  # 使用 Redis 的哪个数据库，默认为 0
spring.redis.timeout=2000  # 设置连接超时时间，单位毫秒
<pre><code class="highlight plaintext">
**使用 `application.yml` 配置：**
</code></pre>
spring:
  redis:
    host: localhost
    port: 6379
    password: your_password  # 如果有密码的话
    database: 0  # 默认数据库
    timeout: 2000  # 连接超时时间（毫秒）
<pre><code class="highlight plaintext">
#### 3、配置 RedisTemplate（可选）

`RedisTemplate` 是 Spring Data Redis 提供的一个类，允许你通过 Java 类与 Redis 进行交互。你可以通过它进行操作 Redis 中的各种数据类型（如 String、List、Hash、Set 等）。

创建一个配置类，定义 `RedisTemplate` 和 `StringRedisTemplate`。
</code></pre>
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.connection.jedis.JedisConnectionFactory;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer;
import org.springframework.data.redis.serializer.StringRedisSerializer;

<p>@Configuration<br>public class RedisConfig {</p>
<pre><code>@Bean
public JedisConnectionFactory jedisConnectionFactory() &#123;
    JedisConnectionFactory factory = new JedisConnectionFactory();
    factory.setHostName(&quot;localhost&quot;);
    factory.setPort(6379);
    return factory;
&#125;

@Bean
public RedisTemplate&lt;String, Object&gt; redisTemplate() &#123;
    RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;&gt;();
    template.setConnectionFactory(jedisConnectionFactory());
    template.setKeySerializer(new StringRedisSerializer());
    template.setValueSerializer(new GenericJackson2JsonRedisSerializer());
    return template;
&#125;

@Bean
public StringRedisTemplate stringRedisTemplate() &#123;
    StringRedisTemplate template = new StringRedisTemplate();
    template.setConnectionFactory(jedisConnectionFactory());
    return template;
&#125;
</code></pre>
<p>}</p>
<pre><code class="highlight plaintext">
- `RedisTemplate`：用于处理各种类型的 Redis 数据结构。

- `StringRedisTemplate`：主要用于操作字符串类型的数据，通常用于简化操作。

#### 4、使用 Redis

一旦配置完成，你就可以在 Spring Boot 中通过 `RedisTemplate` 或 `StringRedisTemplate` 来进行 Redis 操作了

**1）、使用 `StringRedisTemplate` 进行字符串操作：**
</code></pre>
<p>import org.springframework.beans.factory.annotation.Autowired;<br>import org.springframework.data.redis.core.StringRedisTemplate;<br>import org.springframework.stereotype.Service;</p>
<p>@Service<br>public class RedisService {</p>
<pre><code>@Autowired
private StringRedisTemplate stringRedisTemplate;

public void setValue(String key, String value) &#123;
    stringRedisTemplate.opsForValue().set(key, value);
&#125;

public String getValue(String key) &#123;
    return stringRedisTemplate.opsForValue().get(key);
&#125;
</code></pre>
<p>}</p>
<pre><code class="highlight plaintext">
**2）、使用 `RedisTemplate` 进行更复杂的数据类型操作：**
</code></pre>
<p>import org.springframework.beans.factory.annotation.Autowired;<br>import org.springframework.data.redis.core.RedisTemplate;<br>import org.springframework.stereotype.Service;</p>
<p>@Service<br>public class RedisService {</p>
<pre><code>@Autowired
private RedisTemplate&lt;String, Object&gt; redisTemplate;

// 设置 Hash 数据
public void setHash(String hashKey, String key, String value) &#123;
    redisTemplate.opsForHash().put(hashKey, key, value);
&#125;

// 获取 Hash 数据
public Object getHash(String hashKey, String key) &#123;
    return redisTemplate.opsForHash().get(hashKey, key);
&#125;

// 设置 List 数据
public void setList(String listKey, Object value) &#123;
    redisTemplate.opsForList().leftPush(listKey, value);
&#125;

// 获取 List 数据
public Object getList(String listKey) &#123;
    return redisTemplate.opsForList().leftPop(listKey);
&#125;
</code></pre>
<p>}</p>
<pre><code class="highlight plaintext">
#### 5、使用Redis缓存

Spring Boot 可以与 Redis 集成，作为缓存解决方案。你可以使用 `@Cacheable` 和 `@CachePut` 注解来实现缓存功能。

首先，启用缓存支持，在启动类或者配置类中添加 `@EnableCaching` 注解。
</code></pre>
<p>import org.springframework.cache.annotation.EnableCaching;<br>import org.springframework.boot.SpringApplication;<br>import org.springframework.boot.autoconfigure.SpringBootApplication;</p>
<p>@SpringBootApplication<br>@EnableCaching  &#x2F;&#x2F; 启用缓存<br>public class Application {</p>
<pre><code>public static void main(String[] args) &#123;
    SpringApplication.run(Application.class, args);
&#125;
</code></pre>
<p>}</p>
<pre><code class="highlight plaintext">
然后，你可以在方法上使用 `@Cacheable` 和 `@CachePut` 注解：
</code></pre>
<p>import org.springframework.cache.annotation.Cacheable;<br>import org.springframework.stereotype.Service;</p>
<p>@Service<br>public class UserService {</p>
<pre><code>@Cacheable(value = &quot;users&quot;, key = &quot;#id&quot;)
public User getUserById(Long id) &#123;
    // 模拟从数据库中查询用户
    return new User(id, &quot;John Doe&quot;);
&#125;
</code></pre>
<p>}</p>
<pre><code class="highlight plaintext">
- `@Cacheable(value = &quot;users&quot;, key = &quot;#id&quot;)`：缓存 `getUserById` 方法的结果，缓存的键为 `id`，缓存的值是返回的 `User` 对象。

- `value`：缓存名称。

- `key`：缓存的键，可以是方法参数。

#### 6、使用 Redis 作为消息队列（可选）

你还可以将 Redis 用作消息队列，通过 Redis 发布/订阅功能实现异步消息处理。
</code></pre>
<p>import org.springframework.beans.factory.annotation.Autowired;<br>import org.springframework.data.redis.listener.ChannelTopic;<br>import org.springframework.data.redis.listener.MessageListener;<br>import org.springframework.data.redis.listener.MessageListenerContainer;<br>import org.springframework.data.redis.listener.RedisMessageListenerContainer;<br>import org.springframework.data.redis.connection.Message;</p>
<p>@Configuration<br>public class RedisMessageConfig {</p>
<pre><code>@Autowired
private RedisTemplate&lt;String, String&gt; redisTemplate;

@Bean
public MessageListenerContainer messageListenerContainer(RedisConnectionFactory redisConnectionFactory, MessageListener messageListener) &#123;
    RedisMessageListenerContainer container = new RedisMessageListenerContainer();
    container.setConnectionFactory(redisConnectionFactory);
    container.addMessageListener(messageListener, new ChannelTopic(&quot;myChannel&quot;));
    return container;
&#125;

@Bean
public MessageListener messageListener() &#123;
    return new MessageListener() &#123;
        @Override
        public void onMessage(Message message, byte[] pattern) &#123;
            System.out.println(&quot;Received: &quot; + message.toString());
        &#125;
    &#125;;
&#125;
</code></pre>
<p>}</p>
<pre><code class="highlight plaintext">
#### 7、启动Redis 服务

确保 Redis 服务已启动并正在监听默认的 6379 端口。你可以使用以下命令启动 Redis：
</code></pre>
<h1 id="启动-Redis-服务"><a href="#启动-Redis-服务" class="headerlink" title="启动 Redis 服务"></a>启动 Redis 服务</h1><p>redis-server</p>
<pre><code>
**总结**

通过以上步骤，你可以轻松地将 Redis 集成到 Spring Boot 项目中，并利用 Spring Data Redis 提供的功能进行 Redis 操作。你可以使用 Redis 来存储缓存数据、消息队列、会话数据，甚至用来管理复杂的数据结构。
</code></pre>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://xz613.github.io">John Doe</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://xz613.github.io/2025/03/11/springboot%E7%AC%94%E8%AE%B0%E5%B0%8F%E7%BB%93/">https://xz613.github.io/2025/03/11/springboot%E7%AC%94%E8%AE%B0%E5%B0%8F%E7%BB%93/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://xz613.github.io" target="_blank">他乡遇故知</a>！</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="/img/avator.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.4/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.4/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related full-width" href="/2025/03/11/%E7%8B%82%E7%A5%9Espring5/" title="狂神spring5"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">狂神spring5</div></div><div class="info-2"><div class="info-item-1">目录标题 Spring1.1 简介1.2 优点1.3 组成1.4 拓展 IOC理论推导 HelloSpring IOC创建对象的方式 Spring配置5.1 取别名5.2 Bean的配置5.3 import 依赖注入6.1 构造器注入6.2 Set方式注入【重点】6.3 拓展方式注入6.4 Bean作用域 Bean的自动装配7.1 测试7.2 ByName自动装配7.3 ByType自动装配7.4 使用注解实现自动装配 使用注解开发 用JAVA的方式配置Spring 代理模式10.1 静态代理10.2 加深理解10.3 动态代理 AOP11.1 什么是AOP11.2 AOP在Spring中的作用11.3 使用Spring实现AOP 整合Mybatis12.1 回忆Mybatis12.2 Mybatis-Spring 声明式事务13.1 回顾事务13.2 Spring中的事务管理 总结  1.Spring1.1...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/avator.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">John Doe</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">9</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>关注我</span></a><div class="card-info-social-icons"><a class="social-icon" href="/13048559773@163.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">这是我的博客</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#springboot-%E6%96%87%E6%A1%A3%E5%8F%82%E8%80%83%E8%BF%9E%E6%8E%A5%EF%BC%9A"><span class="toc-number">1.</span> <span class="toc-text">springboot 文档参考连接：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%EF%BC%8C%E4%BB%80%E4%B9%88%E6%98%AFSpringBoot"><span class="toc-number">2.</span> <span class="toc-text">一，什么是SpringBoot</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%EF%BC%8C%E4%BB%80%E4%B9%88%E6%98%AF%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%EF%BC%9F"><span class="toc-number">3.</span> <span class="toc-text">二，什么是微服务架构？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%EF%BC%8CSpringBoot-%E5%BF%AB%E9%80%9F%E5%88%9B%E5%BB%BA"><span class="toc-number">4.</span> <span class="toc-text">三，SpringBoot 快速创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%EF%BC%8C%E5%8E%9F%E7%90%86%E5%88%9D%E6%8E%A2"><span class="toc-number">5.</span> <span class="toc-text">四，原理初探</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%8C%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D"><span class="toc-number">5.1.</span> <span class="toc-text">1，自动装配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%8C%E5%90%AF%E5%8A%A8%E5%99%A8"><span class="toc-number">5.2.</span> <span class="toc-text">2，启动器</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E9%85%8D%E7%BD%AE"><span class="toc-number"></span> <span class="toc-text">默认配置</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E7%9A%84%E9%85%8D%E7%BD%AE"><span class="toc-number"></span> <span class="toc-text">开发环境的配置</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%E7%9A%84%E9%85%8D%E7%BD%AE"><span class="toc-number"></span> <span class="toc-text">测试环境的配置</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E8%B7%AF%E5%BE%84"><span class="toc-number"></span> <span class="toc-text">设置静态资源路径</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE-Druid-%E6%95%B0%E6%8D%AE%E6%BA%90"><span class="toc-number"></span> <span class="toc-text">配置 Druid 数据源</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Druid-%E9%85%8D%E7%BD%AE"><span class="toc-number"></span> <span class="toc-text">Druid 配置</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#MyBatis%E9%85%8D%E7%BD%AE"><span class="toc-number"></span> <span class="toc-text">MyBatis配置</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number"></span> <span class="toc-text">Please log in</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8-Redis-%E6%9C%8D%E5%8A%A1"><span class="toc-number"></span> <span class="toc-text">启动 Redis 服务</span></a></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/11/springboot%E7%AC%94%E8%AE%B0%E5%B0%8F%E7%BB%93/" title="springboot笔记小结">springboot笔记小结</a><time datetime="2025-03-11T11:20:40.000Z" title="发表于 2025-03-11 19:20:40">2025-03-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/11/%E7%8B%82%E7%A5%9Espring5/" title="狂神spring5">狂神spring5</a><time datetime="2025-03-11T11:14:04.000Z" title="发表于 2025-03-11 19:14:04">2025-03-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/11/Spring%E7%AC%94%E8%AE%B0/" title="Spring笔记">Spring笔记</a><time datetime="2025-03-11T11:12:33.000Z" title="发表于 2025-03-11 19:12:33">2025-03-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/11/Mybatis%E9%BB%91%E9%A9%AC%E7%AC%94%E8%AE%B0/" title="Mybatis黑马笔记">Mybatis黑马笔记</a><time datetime="2025-03-11T11:06:54.000Z" title="发表于 2025-03-11 19:06:54">2025-03-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/11/Redis%E5%B0%8F%E7%BB%93/" title="Redis小结">Redis小结</a><time datetime="2025-03-11T11:00:26.000Z" title="发表于 2025-03-11 19:00:26">2025-03-11</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By John Doe</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.3.5"></script><script src="/js/main.js?v=5.3.5"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (false) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.4.1/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>