---
title: Redis小结
date: 2025-03-11 19:00:26
tags:
---

## **Redis 课程相关笔记**

### **一·、概述**

**Redis 是什么？**

Redis:  **Re**mote **Di**ctionary **S**erver (远程服务字典)， 用C语言开发的，完全免费的， 最常用的NOSQL 数据库之一。

**特点**

1. **支持数据的持久化：**可以将内存中的数据加载到磁盘中，重启的时候又点出来使用。
2. 支持  **String , List , Set ,  Zset ,hash** 数据结构的存储。
3. 支持数据的备份 **master - slave** 模式

​

### **二、redis的持久化**

**Redis**的**持久化机制** 确保了redis的数据不会因为服务器的重启或宕机而丢失数据。Redis 的持久化有两个主要的方式。

1、**RDB (Redis Database)**： 快照持久化

2、**AOF (Append Only File):**  日志持久化

**1、RDB持久化**

RDB 持久化方式通常是在隔一段时间里，将Redis的数据集保存为一个二级制文件（通常为 dump.rdb），每当发生rdb持久化时，Redis就会生成一个rdb文件。

**工作原理：**

- Redis会在后台执行 fork() 操作，创建一个子进程来执行持久化操作。父进程继续处理客户端请求，子进程负责将当前内存中的数据保存到磁盘。
- 快照文件（dump.rdb）保存的是数据库Redis的完整副本，因此他是一个时间点的备份。

**配置：**

你可以通过 redis.conf 文件中的配置来控制持久化的行为

```
save 900 1      # 每 900 秒（15 分钟）如果至少有 1 个键发生变化，则进行持久化
save 300 10     # 每 300 秒（5 分钟）如果至少有 10 个键发生变化，则进行持久化
save 60 10000   # 每 60 秒（1 分钟）如果至少有 10000 个键发生变化，则进行持久化
```

**优缺点：**

- **优点：**
    - 操作速度较快，适用于持久化间隔较长的场景。
    - 快照文件较为紧凑，适合用做备份。
- **缺点：**
    - 数据丢失：RDB 只能确保某一时间点的数据保存，若在生成快照前崩溃，可能会丢失最近一短时间的数据。
    - 不适合用于高频率写入的场景。

**2、AOF持久化**

AOF持久化是通过记录写操作来持久化数据。每当redis执行写操作时，它就会将AOF命令追加到AOF文件中。启动redis时，会重新执行AOF文件中的指令，恢复数据库的转台。

**特点**

- **持久化方式：**AOF记录所有对数据库的写操作，不同于RDB的快照式持久化，AOF是命令式持久化。

- **同步策略：**
    - appendsync always:  每次写操作都立即同步到AOF文件，确保最大程度的数据持久性，但会对性能造成损害。
    - appendsync everysc:  每秒同步一次，权衡了持久性和性能，默认配置。
    - appendsync no: 完全依赖操作系统进行同步，可能会丢失数据，但性能最佳。

**优点：**

- **持久性强：**相较RDB,AOF保证每一条命令都被持久化，数据丢失的概率小。

**缺点：**

- **文件较大：**随着时间推移，AOF文件会不断增长。
- **回复速度慢：**比RDB慢，因为要按顺序放每个写操作。



### 三、redis 的锁有哪些，是怎么实现的。

**1、SETNX**

只有该键不存在的时候才会设置该键，常用来设置互斥锁。

- **加锁**：使用SETNX设置一个唯一的锁标识，返回 1 表示成功加锁，返回 0 则表示锁已经存在。
- **解锁**：使用 del 指令删除锁。

```code
SETNX lock_key 1   # 只有当lock_key不存在时，才会成功设置。
```

- **优点**：简单，直接。

- **缺点**：没有过期时间，容易导致死锁。如果客户端在持有锁的过程中崩溃，就会形成死锁。

为了解决这个问题使用  **SET命令 + EX (过期时间)**  来定时释放锁。

```
SET lock_key unique_value NX EX 10
```

- NX: 表示key 不存在的时候才上锁
- EX 10  表示锁存在的时间是10秒

优缺点

- **优点：**避免了死锁
- **缺点：**如果设置的过期时间过短，可能导致锁提前过期，进而造成并发问题；如果过期时间过长，则可能导致锁无法及时释放。



**2、Redlock 算法**

redlock 是官方提出的 redis 提出的分布式方案。使用多个（至少5个） 来提供锁服务，从而避免单点出现故障。

**基本原理：**

- 生成唯一标识（如UUID ）作为锁的值。
- 在多个 redis 实例中尝试同时获得锁。
- 设置锁的过期时间，确保单个客户端崩溃，锁也能自动释放。
- 如果至少有一部分 redis 实例成功获取了锁。并且锁的持有时间满足最小阈值（比如2/3实例成功），就认为获取锁成功。
- 如果无法成功获取锁，则重试或返回失败。

**优缺点：**

优点：具有高可用性，避免单点故障。

缺点：实现复杂，需要建立多个实例。





### 常见面试题：

#### **1、Redis为什么这么快？**

——1）、基于内存存储。没有使用磁盘IO，读写速度快。

​	2）、**使用IO多路复用模型:**  Redis 采用多路复用模型，Redis 使用单线程来做轮询，建数据库的操作都转换成了事件，不在网络 I/O 上浪费过多的时间。

​	3）、Redis 的底层对每种数据结构都做了优化，目的就是为了最求更快的速度。



#### **2、redis的集群模式有哪些？**

**1）、Redis Cluster 模式：**

Redis最常用的集群部署方式。4.0映入的核心特性。

**特点：**

- **数据分片（sharding）：**将数据分布到多个节点上，每个Redis节点 （实例） 只负责一个子集，这样就实现了水平扩展。
- **哈希槽（Hash slot）：**Redis 将整个键空间（16384个槽）分为16384个哈希槽。每个键都会映射到一个哈希槽，进而映射到集群中的一个节点。Redis 集群根据键的哈希值来确定存储在那个节点上。
- **高可用性和故障转移：**通过**主从复制**实现高可用。每个主节点有一个或多个从节点，在主节点出现故障时，redis 会自动将一个从节点提升为主节点，确保数据的可用性。

**工作流程:**

- 当客户端请求一个键时，Redis 集群会根据键的哈希值来确定该键应该存储在那个节点的哈希槽，如果客户端连接到一个节点，但该键在另一个节点上时，给节点会返回一个重定向消息，告诉客户端去连接正确的节点。
- 集群中的某个节点只存储 一部分的键值对，称为主节点。它可以有多个从节点进行数据复制。主节点和从节点通过同步机制确保数据的一致性。



**2）、Redis Sentinel 模式**

主要用于**主从模式**下的**故障转移**和**监控**，不提供数据分片。

**特点：**

- **主从复制：**部署一个为主节点，其余为从节点，主节点负责写操作，从节点仅存储数据。
- **高可用和故障转移：**主节点故障，从节点选举产生新的主节点。告知客户端新的主节点地址。
- **集群监控和报警：** Sentinel 可以监控从节点中的 redis 节点的健康状态，出现问题会及时报警。

**工作流程：**

1）、**监控节点**：Redis Sentinel 会定期检查集群中所有 Redis 节点的健康状况。

2）、**故障检测和故障转移**：当 Sentinel 检测到主节点故障时，会进行故障转移，选择一个从节点提升为新的主节点。

3）、**通知客户端**：当主节点切换后，Sentinel 会将新的主节点地址推送给客户端，客户端根据新的主节点信息重新连接。



#### **3、Redis 分片：**

Redis 分片指的是通过将数据分布到多个独立的 Redis 实例上，来实现数据的水平扩展。这种方式在 Redis Cluster 模式引入之前常用于实现 Redis 的分布式部署。

在 Redis 分片模式下，客户端需要知道多个 Redis 实例的具体位置，并直接将请求发送到对应的实例。数据分片通常基于某种哈希算法，将数据分配到不同的实例中。



#### **4、redis的淘汰策略：**

1，noevication：不淘汰，拒绝写操作；

2、volatile-lru:对设置了过期时间且最近使用最少的键清理；

3，allkeys-lru：对最近使用最少的键进行清理；

4，volatile-ttl：对设置了过期时间且最接近过期时间的键进行清理；

5，allkeys-random：对所有的键随机清理；

6，voltaile-random:对设置了过期时间的key随机清理;

7，voltile-lfu:对设置了过期时间且访问频率最低的键清理;

8，allkeys-lfu:对访问频率最低的键清理。



#### 5**、什么是热Key问题，如何解决热key问题？**

在分布式系统中，某个特定的key被频繁的访问，从而形成系统瓶颈或性能问题的现象。

1、**使用数据分片：**Redis Cluster通过自动将数据分到多个节点上，可以将热key分布到不同的Redis节点，避免单个节点过载；

2、**分布式缓存：**使用Redis 实例作为缓存层，将热key 的访问负载分散到多个实例中；

3、请求限流：结合对Redis实现对热可以的限流，防止过多的请求集中在以恶key上；

4、**缓存穿透和预热：**将实例分布到多个Redis缓存区域中，避免在高并发时频繁的访问同一节点；也可以使用Bloom Filter来减少无效请求；

5、**对象拆分和层级缓存：**对于访问量极高的对象，可以将大的对象吃啊分成多个小的对象存储在不同的key下，通过访问多个key来分散热key 的负载；

6、**Redis 的LRU和 LFU策略：**清理不常用的缓存数据，确保热key能持续保存在内存中。冷数据被淘汰，有助于解决热key被频繁访问而占用过多内存的问题。



#### **6、什么是缓存击穿、缓存穿透、缓存雪崩？以及对应的解决方案？**

**缓存击穿：**出现热key现象，而此时这个key失效了，持续的大并发就会穿破缓存，直接请求数据库。

1、可以设置热点数据永不过期（不推荐）。

2、加互斥锁：减少后端服务的压力；

**缓存穿透：**大量的请求在内存数据库中查找失败，转而向吃鸡数据库中发送请求，此时持久层数据库就会很大的压力。

1、使用 布隆过滤器在缓存层数据库中过滤请求，减少压力。

2、缓存空对象；

**缓存雪崩：**在某一个时间段，缓存集中过期失效。DB由于压力过大而挂掉。

1、redis高可用：搭建集群，一台挂掉之后，其他的还可以继续工作。

2、数据预热：设置不同的过期时间，让缓存失效的时间点均匀。

3、限流降级：加锁或者队列控制数据库写换缓存的数量。减少DB压力。



#### **7、如何解决Redis和数据库的一致性问题？**

1、**直接删除缓存：**数据库更新直接删除相关缓存，迫使下次访问重新从数据库中加载数据并更新缓存。

2、**缓存更新**：在更新数据库时同时更新缓存，确保缓存中的数据始终和数据库中的保持一致。

3、**过期时间：**设置过期时间，定期过期并从数据库中重新加载数据。

4、**消息队列：**更新数据库时，发一条消息，通知后台进程更新缓存。

5、**双写一致性：**使用缓存旁路策略，通过应用层同时处理数据库和缓存的更新。

6、**分布式事务：**通过三个阶段确保分布式系统中缓存和数据库中的一致。

7、**分布式事务源：**将所有的更行操作转化成事件流，并通过事件流来确保数据库和缓存的一致性。

8、**分布式补偿机制：**通当数据更新成功但是缓存更新失败时，可以通过后台任务或补偿机制来修复数据的一致性。

9、**缓存预热批量更新：**定时批量更新缓存。

10、**lua脚本：**Redis中执行lua脚本，确保缓存更新的一致性。



#### 8、Redis 支持哪几种数据类型？适用场景，底层结构？

**支持5中基本的数据类型：**

1、String，适用于存储单一的值、动态字符串；

2、Hash、存储对象数据等，Hash table实现；

3、Set，无序去重的集合，社交网络共同好友，共同关注， Hash Table 实现，仅有值。

4、List，消息队列，任务队列等，双向链表；

5、Zset，有序集合，排行榜等，跳表和哈希表。

**3种特殊的数据类型：**

1、Bitmap：存储大量的布尔值如记录签到打卡等，位数组实现；

2、Hyperlog，记录基数的统计，如记录网站的访问人数，Hyperloglog算法；

3、Geospatial，存储地理位置和经纬度信息， 有序集合实现。



**9、bigkey有什么危害？怎么发现bigkey和hotkey？**

1、Bigkey占用了大量的内存会造成内存压力。

2、一个Bigkey 需要被读取或修改，可能会导致长时间的阻塞操作。

3如果客户端从Redis中获取bigkey ，传输过程中可能会占用大量宽带，增加延迟。

可以使用 memory usage key_name 指令查看某个键的占用内存的大小。

使用Redis 慢查询日志：如果某个键频繁的出现在慢查询中，那么他可能是一个hotkey。



**10、什么是布隆过滤器？有什么问题？**

布隆过滤器是一个空间利用率极高的概率型数据结构，用于检测一个元素是否在一个集合。它能快速地回答某个元素是否存在于集合中，但可能会出现**误判**，即错误地判断某个元素存在；但它**绝不会误判不存在**。布隆过滤器适用于需要快速、空间高效地判断元素是否存在于集合中的场景。



**Java代码实现：**

我们可以使用`Guava`库来实现布隆过滤器。Guava是Google开发的一个开源Java类库，其中就包括了布隆过滤器的实现。

**添加依赖**

如果你使用的是Maven构建工具，可以在`pom.xml`中添加以下依赖：

```
<dependency>
    <groupId>com.google.guava</groupId>
    <artifactId>guava</artifactId>
    <version>31.0-jre</version>
</dependency>
```

**代码示例：**

```
import com.google.common.base.Charsets;
import com.google.common.hash.BloomFilter;
import com.google.common.hash.Funnels;

public class CacheSystemWithBloomFilter {

    // 创建一个布隆过滤器，预计容量为10000，误判率为0.1%
    private static BloomFilter<String> bloomFilter = BloomFilter.create(Funnels.stringFunnel(Charsets.UTF_8), 10000, 0.001);

    public static String checkCache(String request) {
        // 如果请求已经在布隆过滤器中，说明缓存已经命中
        if (bloomFilter.mightContain(request)) {
            System.out.println("Cache hit: Request already processed.");
            return null;  // 直接从缓存返回
        } else {
            // 如果请求不在布隆过滤器中，则说明是首次请求，需要查询数据库或API
            System.out.println("Cache miss: Processing request.");
            String response = "Processed data for " + request;
            // 将请求标记为已处理，并缓存结果
            bloomFilter.put(request);
            return response;
        }
    }

    public static void main(String[] args) {
        // 测试请求
        String[] requests = {"request_1", "request_2", "request_3", "request_1"};
        for (String req : requests) {
            String result = checkCache(req);
            if (result != null) {
                System.out.println(result);
            }
        }
    }
}
```


